#!/usr/bin/perl -s

if(!$ARGV[0]) {
    print <<MOO
Usage: lang.pl [-p=<prefix>] <language file>

When running this program. <prefix>.h and <prefix>.c will be created in the
"current directory". <prefix> is "lang" by default.
MOO
;
    exit;
}

my $prefix = $p;
if(!$prefix) {
    $prefix="lang";
}

my $input = $ARGV[0];

open(HFILE, ">$prefix.h");
open(CFILE, ">$prefix.c");

print HFILE <<MOO
/* This file was automaticly generated using genlang */
/*
 * The str() macro/functions is how to access strings that might be
 * translated. Use it like str(MACRO) and expect a string to be
 * returned!
 */
#define str(x) language_strings[x]

/* this is the array with all the strings */
extern unsigned char *language_strings[];

/* The enum below contains all available strings */
enum {
MOO
    ;

print CFILE <<MOO
/* This file was automaticly generated using genlang, the strings come
   from "$input" */

unsigned char *language_strings[]={
MOO
    ;

open(LANG, "<$input");
while(<LANG>) {
    $line++;
    if($_ =~ / *\#/) {
        # comment
        next;
    }
    # get rid of DOS newlines
    $_ =~ s/\r//g;
    if($_ =~ / *([a-z]+): *(.*)/) {
        ($var, $value) = ($1, $2);
        # print "$var => $value\n";

        $set{$var} = $value;

        if( (($var eq "new") && $value && ($value !~ /^\"(.*)\" *$/)) ||
            (($var eq "eng") && ($value !~ /^\"(.*)\" *$/)) ) {
            print "$input:$line:missing quotes for ".$set{'id'}."\n";
            $errors++;
            next;
        }

        if($var eq "new") {
            # the last one for a single phrase

            if(!$value || ($value eq "\"\"") ) {
                # if not set, get the english version
                $value = $set{'eng'};
            }

            print HFILE " ".$set{'id'}.",\n";
            print CFILE "   $value,\n";

            undef %set;
        }

    }

}
close(LANG);


print HFILE <<MOO
};
/* end of generated enum list */
MOO
    ;

print CFILE <<MOO
};
/* end of generated string list */
MOO
    ;

close(CFILE);
close(HFILE);

exit $errors;
