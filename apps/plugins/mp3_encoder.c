//    Shine is an MP3 encoder
//    Copyright (C) 1999-2000  Gabriel Bouvigne
//
//    This library is free software; you can redistribute it and/or
//    modify it under the terms of the GNU Library General Public
//    License as published by the Free Software Foundation; either
//    version 2 of the License, or (at your option) any later version.
//
//    This library is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//    Library General Public License for more details.

#include <stdio.h>

#define samp_per_frame   1152
#define samp_per_frame2   576
#define HAN_SIZE          512
#define SBLIMIT            32
#define WAVE_RIFF_PCM       0
#define MAX_CHANNELS        2
#define MAX_GRANULES        2
#define HTN	               34
#define true                1
#define false               0
#define uint32 unsigned   int
#define uint16 unsigned short
#define uint8  unsigned  char
#define enct8  unsigned  char
#ifndef bool
#define bool              int
#endif

enum e_byte_order { order_unknown, order_bigEndian, order_littleEndian };

#include "plugin.h"
#define PFILE       int*
#define memcpy      rb->memcpy
#define memset      rb->memset

PLUGIN_HEADER

static struct  plugin_api* rb;
extern char    iramcopy[];
extern char    iramstart[];
extern char    iramend[];

typedef struct {
    PFILE file;
    int  channels;
    int  bits;
    long samplerate;
    long total_samples;
    long length;
} wave_t;

typedef struct {
    int  type;
    int  layr;
    int  mode;
    int  bitr;
    int  emph;
    int  padding;
    long bits_per_frame;
    long bitrate_index;
    int  samplerate_index;
    int crc;
    int ext;
    int mode_ext;
    int copyright;
    int original;
} mpeg_t;

typedef struct {
    enum e_byte_order byte_order; 
    char*             infile;
    wave_t            wave;
    char*             outfile;
    mpeg_t            mpeg;
} config_t;

typedef struct {
    int     bitpos;
    uint32  bbuf[257];
} BF_Data;

/* Side information */
typedef struct {
    unsigned part2_3_length;
    unsigned big_values;
    int      count1;
    unsigned global_gain;
    unsigned table_select[4];
    unsigned region0_count;
    unsigned region1_count;
    unsigned address1;
    unsigned address2;
    unsigned address3;
    long     quantizerStepSize;
} side_info_t;

struct huffcodetab {
  int                 xlen;    /*max. x-index+                */
  int                 ylen;    /*max. y-index+                */
  int                 linbits; /*number of linbits            */
  int                 linmax;  /*max number stored in linbits	*/
  const uint16        *table;  /*pointer to array[xlen][ylen] */
  const uint8         *hlen;   /*pointer to array[xlen][ylen] */
};

/* !!!!!!!! start of IRAM area: do not insert before x_int1 array !!!!!!!!!!!!! */
short     x_int0      [HAN_SIZE]              IBSS_ATTR; //  1024 Bytes
int       mdct_freq   [2][2][samp_per_frame2] IBSS_ATTR; //  9216 Bytes
short     x_int1      [HAN_SIZE]              IBSS_ATTR; //  1024 Bytes
/* !!!!!!!!!!!!!!!!!!!!! here you may insert other data !!!!!!!!!!!!!!!!!!!!!!! */
uint8     int2idx     [4096]                  IBSS_ATTR; //  4096 Bytes
enct8     enc_data    [2][2][samp_per_frame2] IBSS_ATTR; //  4608 Bytes
short     y_int       [64]                    IBSS_ATTR; //   256 Bytes
int       off         [2]                     IBSS_ATTR; //    16 Bytes
int       scalefac_long[23]                   IBSS_ATTR; //    96 Bytes
int       mdct_in     [36]                    IBSS_ATTR; //   144 Bytes
int       sb_sample   [2][3][18][SBLIMIT]     IBSS_ATTR; // 13824 Bytes
BF_Data   CodedData                           IBSS_ATTR; //  1040 Bytes
int       ca_int      [8]                     IBSS_ATTR; //    32 Bytes
int       cs_int      [8]                     IBSS_ATTR; //    32 Bytes
int       win_int     [18][36]                IBSS_ATTR; //  2592 Bytes
short     filter_int  [SBLIMIT][64]           IBSS_ATTR; //  8192 Bytes
short     enwindow_int[512]                   IBSS_ATTR; //  1024 Bytes
uint8     ht_count1   [2][2][16]              IBSS_ATTR; //    64 Bytes
uint16    t1HB        [  4]                   IBSS_ATTR; //   Bytes
uint16    t2HB        [  9]                   IBSS_ATTR; //   Bytes
uint16    t3HB        [  9]                   IBSS_ATTR; //   Bytes
uint16    t5HB        [ 16]                   IBSS_ATTR; //   Bytes
uint16    t6HB        [ 16]                   IBSS_ATTR; //   Bytes
uint16    t7HB        [ 36]                   IBSS_ATTR; //   Bytes
uint16    t8HB        [ 36]                   IBSS_ATTR; //   Bytes
uint16    t9HB        [ 36]                   IBSS_ATTR; //   Bytes
uint16    t10HB       [ 64]                   IBSS_ATTR; //   Bytes
uint16    t11HB       [ 64]                   IBSS_ATTR; //   Bytes
uint16    t12HB       [ 64]                   IBSS_ATTR; //   Bytes
uint16    t13HB       [256]                   IBSS_ATTR; //   Bytes
uint16    t15HB       [256]                   IBSS_ATTR; //   Bytes
uint16    t16HB       [256]                   IBSS_ATTR; //   Bytes
uint16    t24HB       [256]                   IBSS_ATTR; //   Bytes
uint8     t1l         [  4]                   IBSS_ATTR; //   Bytes
uint8     t2l         [  9]                   IBSS_ATTR; //   Bytes
uint8     t3l         [  9]                   IBSS_ATTR; //   Bytes
uint8     t5l         [ 16]                   IBSS_ATTR; //   Bytes
uint8     t6l         [ 16]                   IBSS_ATTR; //   Bytes
uint8     t7l         [ 36]                   IBSS_ATTR; //   Bytes
uint8     t8l         [ 36]                   IBSS_ATTR; //   Bytes
uint8     t9l         [ 36]                   IBSS_ATTR; //   Bytes
uint8     t10l        [ 64]                   IBSS_ATTR; //   Bytes
uint8     t11l        [ 64]                   IBSS_ATTR; //   Bytes
uint8     t12l        [ 64]                   IBSS_ATTR; //   Bytes
uint8     t13l        [256]                   IBSS_ATTR; //   Bytes
uint8     t15l        [256]                   IBSS_ATTR; //   Bytes
uint8     t16l        [256]                   IBSS_ATTR; //   Bytes
uint8     t24l        [256]                   IBSS_ATTR; //   Bytes
struct huffcodetab ht [HTN]                   IBSS_ATTR; //   Bytes

static const uint8 ht_count1_const[2][2][16] =
{ { { 1,  5,  4,  5,  6,  5, 4, 4, 7, 3, 6, 0, 7, 2, 3, 1 },     /* table0 */
    { 1,  5,  5,  7,  5,  8, 7, 9, 5, 7, 7, 9, 7, 9, 9,10 } },   /* hleng0 */
  { {15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 },     /* table1 */
    { 4,  5,  5,  6,  5,  6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8 } } }; /* hleng1 */

static const uint16  t1HB_const[4]   = {1, 1, 1, 0}; 
static const uint16  t2HB_const[9]   = {1, 2, 1, 3, 1, 1, 3, 2, 0};
static const uint16  t3HB_const[9]   = {3, 2, 1, 1, 1, 1, 3, 2, 0};
static const uint16  t5HB_const[16]  = {1, 2, 6, 5, 3, 1, 4, 4, 7, 5, 7, 1, 6, 1, 1, 0};
static const uint16  t6HB_const[16]  = {7, 3, 5, 1, 6, 2, 3, 2, 5, 4, 4, 1, 3, 3, 2, 0};
static const uint16  t7HB_const[36]  = {1, 2, 10, 19, 16, 10, 3, 3, 7, 10, 5, 3, 11, 4, 13, 17, 8, 4, 12, 11, 18, 15, 11, 2, 7, 6, 9, 14, 3, 1, 6, 4, 5, 3, 2, 0};
static const uint16  t8HB_const[36]  = {3, 4, 6, 18, 12, 5, 5, 1, 2, 16, 9, 3, 7, 3, 5, 14, 7, 3, 19, 17, 15, 13, 10, 4, 13, 5, 8, 11, 5, 1, 12, 4, 4, 1, 1, 0};
static const uint16  t9HB_const[36]  = {7, 5, 9, 14, 15, 7, 6, 4, 5, 5, 6, 7, 7, 6, 8, 8, 8, 5, 15, 6, 9, 10, 5, 1, 11, 7, 9, 6, 4, 1, 14, 4, 6, 2, 6, 0};
static const uint16 t10HB_const[64]  = {1, 2, 10, 23, 35, 30, 12, 17, 3, 3, 8, 12, 18, 21, 12, 7, 11, 9, 15, 21, 32, 40, 19, 6, 14, 13, 22, 34, 46, 23, 18, 7, 20, 19, 33, 47, 27, 22, 9, 3, 31, 22, 41, 26, 21, 20, 5, 3, 14, 13, 10, 11, 16, 6, 5, 1, 9, 8, 7, 8, 4 , 4, 2, 0};
static const uint16 t11HB_const[64]  = {3, 4, 10, 24, 34, 33, 21, 15, 5, 3, 4, 10, 32, 17, 11, 10, 11, 7, 13, 18, 30, 31, 20, 5, 25, 11, 19, 59, 27, 18, 12, 5, 35, 33, 31, 58, 30, 16, 7, 5, 28, 26, 32, 19, 17, 15, 8, 14, 14, 12, 9, 13, 14, 9, 4, 1, 11, 4, 6, 6, 6, 3, 2, 0};
static const uint16 t12HB_const[64]  = {9, 6, 16, 33, 41, 39, 38, 26, 7, 5, 6, 9, 23, 16, 26, 11, 17, 7, 11, 14, 21, 30, 10, 7, 17, 10, 15, 12, 18, 28, 14, 5, 32, 13, 22, 19, 18, 16, 9, 5, 40, 17, 31, 29, 17, 13, 4, 2, 27, 12, 11, 15, 10, 7, 4, 1, 27, 12, 8, 12 , 6, 3, 1, 0}; 
static const uint16 t13HB_const[256] = {1, 5, 14, 21, 34, 51, 46, 71, 42, 52, 68, 52, 67, 44, 43, 19, 3, 4, 12, 19, 31, 26, 44, 33, 31, 24, 32, 24, 31, 35, 22, 14, 15, 13, 23, 36, 59, 49, 77, 65, 29, 40, 30, 40, 27, 33, 42, 16, 22,
                                 20, 37, 61, 56, 79, 73, 64, 43, 76, 56, 37, 26, 31, 25, 14, 35, 16, 60, 57, 97, 75, 114, 91, 54, 73, 55, 41, 48, 53, 23, 24, 58, 27, 50, 96, 76, 70, 93, 84, 77, 58, 79, 29, 74, 49, 41, 17, 47, 
                                 45, 78, 74, 115, 94, 90, 79, 69, 83, 71, 50, 59, 38, 36, 15, 72, 34, 56, 95, 92, 85, 91, 90, 86, 73, 77, 65, 51, 44, 43, 42, 43, 20, 30, 44, 55, 78, 72, 87, 78, 61, 46, 54, 37, 30, 20, 16, 53, 
                                 25, 41, 37, 44, 59, 54, 81, 66, 76, 57, 54, 37, 18, 39, 11, 35, 33, 31, 57, 42, 82, 72, 80, 47, 58, 55, 21, 22, 26, 38, 22, 53, 25, 23, 38, 70, 60, 51, 36, 55, 26, 34, 23, 27, 14, 9, 7, 34, 32, 
                                 28, 39, 49, 75, 30, 52, 48, 40, 52, 28, 18, 17, 9, 5, 45, 21, 34, 64, 56, 50, 49, 45, 31, 19, 12, 15, 10, 7, 6, 3, 48, 23, 20, 39, 36, 35, 53, 21, 16, 23, 13, 10, 6, 1, 4, 2, 16, 15, 17, 27, 25, 
                                 20, 29, 11, 17, 12, 16, 8, 1, 1, 0, 1};
static const uint16 t15HB_const[256] = {7, 12, 18, 53, 47, 76, 124, 108, 89, 123, 108, 119, 107, 81, 122, 63, 13, 5, 16, 27, 46, 36, 61, 51, 42, 70, 52, 83, 65, 41, 59, 36, 19, 17, 15, 24, 41, 34, 59, 48, 40, 64, 50, 78, 62, 80, 56, 
                                  33, 29, 28, 25, 43, 39, 63, 55, 93, 76, 59, 93, 72, 54, 75, 50, 29, 52, 22, 42, 40, 67, 57, 95, 79, 72, 57, 89, 69, 49, 66, 46, 27, 77, 37, 35, 66, 58, 52, 91, 74, 62, 48, 79, 63, 90, 62, 40, 38,
                                  125, 32, 60, 56, 50, 92, 78, 65, 55, 87, 71, 51, 73, 51, 70, 30, 109, 53, 49, 94, 88, 75, 66, 122, 91, 73, 56, 42, 64, 44, 21, 25, 90, 43, 41, 77, 73, 63, 56, 92, 77, 66, 47, 67, 48, 53, 36, 20,
                                  71, 34, 67, 60, 58, 49, 88, 76, 67, 106, 71, 54, 38, 39, 23, 15, 109, 53, 51, 47, 90, 82, 58, 57, 48, 72, 57, 41, 23, 27, 62, 9, 86, 42, 40, 37, 70, 64, 52, 43, 70, 55, 42, 25, 29, 18, 11, 11, 
                                  118, 68, 30, 55, 50, 46, 74, 65, 49, 39, 24, 16, 22, 13, 14, 7, 91, 44, 39, 38, 34, 63, 52, 45, 31, 52, 28, 19, 14, 8, 9, 3, 123, 60, 58, 53, 47, 43, 32, 22, 37, 24, 17, 12, 15, 10, 2, 1, 71, 
                                  37, 34, 30, 28, 20, 17, 26, 21, 16, 10, 6, 8, 6, 2, 0};
static const uint16 t16HB_const[256] = {1, 5, 14, 44, 74, 63, 110, 93, 172, 149, 138, 242, 225, 195, 376, 17, 3, 4, 12, 20, 35, 62, 53, 47, 83, 75, 68, 119, 201, 107, 207, 9, 15, 13, 23, 38, 67, 58, 103, 90, 161, 72, 127, 117, 
                                  110, 209, 206, 16, 45, 21, 39, 69, 64, 114, 99, 87, 158, 140, 252, 212, 199, 387, 365, 26, 75, 36, 68, 65, 115, 101, 179, 164, 155, 264, 246, 226, 395, 382, 362, 9, 66, 30, 59, 56, 102,
                                  185, 173, 265, 142, 253, 232, 400, 388, 378, 445, 16, 111, 54, 52, 100, 184, 178, 160, 133, 257, 244, 228, 217, 385, 366, 715, 10, 98, 48, 91, 88, 165, 157, 148, 261, 248, 407, 397, 372,
                                  380, 889, 884, 8, 85, 84, 81, 159, 156, 143, 260, 249, 427, 401, 392, 383, 727, 713, 708, 7, 154, 76, 73, 141, 131, 256, 245, 426, 406, 394, 384, 735, 359, 710, 352, 11, 139, 129, 67, 125,
                                  247, 233, 229, 219, 393, 743, 737, 720, 885, 882, 439, 4, 243, 120, 118, 115, 227, 223, 396, 746, 742, 736, 721, 712, 706, 223, 436, 6, 202, 224, 222, 218, 216, 389, 386, 381, 364, 888, 
                                  443, 707, 440, 437, 1728, 4, 747, 211, 210, 208, 370, 379, 734, 723, 714, 1735, 883, 877, 876, 3459, 865, 2, 377, 369, 102, 187, 726, 722, 358, 711, 709, 866, 1734, 871, 3458, 870, 434, 
                                  0, 12, 10, 7, 11, 10, 17, 11, 9, 13, 12, 10, 7, 5, 3, 1, 3};
static const uint16 t24HB_const[256] = {15, 13, 46, 80, 146, 262, 248, 434, 426, 669, 653, 649, 621, 517, 1032, 88, 14, 12, 21, 38, 71, 130, 122, 216, 209, 198, 327, 345, 319, 297, 279, 42, 47, 22, 41, 74, 68, 128, 120, 221,
                                  207, 194, 182, 340, 315, 295, 541, 18, 81, 39, 75, 70, 134, 125, 116, 220, 204, 190, 178, 325, 311, 293, 271, 16, 147, 72, 69, 135, 127, 118, 112, 210, 200, 188, 352, 323, 306, 285, 
                                  540, 14, 263, 66, 129, 126, 119, 114, 214, 202, 192, 180, 341, 317, 301, 281, 262, 12, 249, 123, 121, 117, 113, 215, 206, 195, 185, 347, 330, 308, 291, 272, 520, 10, 435, 115, 111,
                                  109, 211, 203, 196, 187, 353, 332, 313, 298, 283, 531, 381, 17, 427, 212, 208, 205, 201, 193, 186, 177, 169, 320, 303, 286, 268, 514, 377, 16, 335, 199, 197, 191, 189, 181, 174, 333, 
                                  321, 305, 289, 275, 521, 379, 371, 11, 668, 184, 183, 179, 175, 344, 331, 314, 304, 290, 277, 530, 383, 373, 366, 10, 652, 346, 171, 168, 164, 318, 309, 299, 287, 276, 263, 513, 375, 
                                  368, 362, 6, 648, 322, 316, 312, 307, 302, 292, 284, 269, 261, 512, 376, 370, 364, 359, 4, 620, 300, 296, 294, 288, 282, 273, 266, 515, 380, 374, 369, 365, 361, 357, 2, 1033, 280, 278,
                                  274, 267, 264, 259, 382, 378, 372, 367, 363, 360, 358, 356, 0, 43, 20, 19, 17, 15, 13, 11, 9, 7, 6, 4, 7, 5, 3, 1, 3};

static const uint8 t1l_const[4]  = {1, 3, 2, 3}; 
static const uint8 t2l_const[9]  = {1, 3, 6, 3, 3, 5, 5, 5, 6};
static const uint8 t3l_const[9]  = {2, 2, 6, 3, 2, 5, 5, 5, 6}; 
static const uint8 t5l_const[16]  = {1, 3, 6, 7, 3, 3, 6, 7, 6, 6, 7, 8, 7, 6, 7, 8}; 
static const uint8 t6l_const[16]  = {3, 3, 5, 7, 3, 2, 4, 5, 4, 4, 5, 6, 6, 5, 6, 7}; 
static const uint8 t7l_const[36]  = {1, 3, 6, 8, 8, 9, 3, 4, 6, 7, 7, 8, 6, 5, 7, 8, 8, 9, 7, 7, 8, 9, 9, 9, 7, 7, 8, 9, 9, 10, 8, 8, 9, 10, 10, 10}; 
static const uint8 t8l_const[36]  = {2, 3, 6, 8, 8, 9, 3, 2, 4, 8, 8, 8, 6, 4, 6, 8, 8, 9, 8, 8, 8, 9, 9, 10, 8, 7, 8, 9, 10, 10, 9, 8, 9, 9, 11, 11}; 
static const uint8 t9l_const[36]  = {3, 3, 5, 6, 8, 9, 3, 3, 4, 5, 6, 8, 4, 4, 5, 6, 7, 8, 6, 5, 6, 7, 7, 8, 7, 6, 7, 7, 8, 9, 8, 7, 8, 8, 9, 9}; 
static const uint8 t10l_const[64]  = {1, 3, 6, 8, 9, 9, 9, 10, 3, 4, 6, 7, 8, 9, 8, 8, 6, 6, 7, 8, 9, 10, 9, 9, 7, 7, 8, 9, 10, 10, 9, 10, 8, 8, 9, 10, 10, 10, 10, 10, 9, 9, 10, 10, 11, 11, 10, 11, 8, 8, 9, 10, 10, 10, 11, 11, 9, 8, 9, 10, 10, 11, 11, 11}; 
static const uint8 t11l_const[64]  = {2, 3, 5, 7, 8, 9, 8, 9, 3, 3, 4, 6, 8, 8, 7, 8, 5, 5, 6, 7, 8, 9, 8, 8, 7, 6, 7, 9, 8, 10, 8, 9, 8, 8, 8, 9, 9, 10, 9, 10, 8, 8, 9, 10, 10, 11, 10, 11, 8, 7, 7, 8, 9, 10, 10, 10, 8, 7, 8, 9, 10, 10, 10, 10}; 
static const uint8 t12l_const[64]  = {4, 3, 5, 7, 8, 9, 9, 9, 3, 3, 4, 5, 7, 7, 8, 8, 5, 4, 5, 6, 7, 8, 7, 8, 6, 5, 6, 6, 7, 8, 8, 8, 7, 6, 7, 7, 8, 8, 8, 9, 8, 7, 8, 8, 8, 9, 8, 9, 8, 7, 7, 8, 8, 9, 9, 10, 9, 8, 8, 9, 9, 9, 9, 10}; 
static const uint8 t13l_const[256]  = {1, 4, 6, 7, 8, 9, 9, 10, 9, 10, 11, 11, 12, 12, 13, 13, 3, 4, 6, 7, 8, 8, 9, 9, 9, 9, 10, 10, 11, 12, 12, 12, 6, 6, 7, 8, 9, 9, 10, 10, 9, 10, 10, 11, 11, 12, 13, 13, 7, 7, 8, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 13, 
8, 7, 9, 9, 10, 10, 11, 11, 10, 11, 11, 12, 12, 13, 13, 14, 9, 8, 9, 10, 10, 10, 11, 11, 11, 11, 12, 11, 13, 13, 14, 14, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 14, 10, 9, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 16, 16, 9, 8, 9, 10,
10, 11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 15, 10, 9, 10, 10, 11, 11, 11, 13, 12, 13, 13, 14, 14, 14, 16, 15, 10, 10, 10, 11, 11, 12, 12, 13, 12, 13, 14, 13, 14, 15, 16, 17, 11, 10, 10, 11, 12, 12, 12, 12, 13, 13, 13, 14, 15, 15, 15, 16, 11, 11, 11, 12, 12, 
13, 12, 13, 14, 14, 15, 15, 15, 16, 16, 16, 12, 11, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 16, 15, 16, 16, 13, 12, 12, 13, 13, 13, 15, 14, 14, 17, 15, 15, 15, 17, 16, 16, 12, 12, 13, 14, 14, 14, 15, 14, 15, 15, 16, 16, 19, 18, 19, 16}; 
static const uint8 t15l_const[256]  = {3, 4, 5, 7, 7, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 13, 4, 3, 5, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 10, 11, 11, 5, 5, 5, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 11, 11, 11, 6, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 7, 6, 7,
 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 8, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 11, 11, 11, 12, 9, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 12, 12, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 12, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11,
 12, 12, 12, 9, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 10, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 12, 10, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 11, 10, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 13, 13, 
11, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 12, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 12, 13, 12, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13}; 
static const uint8 t16l_const[256]  = {1, 4, 6, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 9, 3, 4, 6, 7, 8, 9, 9, 9, 10, 10, 10, 11, 12, 11, 12, 8, 6, 6, 7, 8, 9, 9, 10, 10, 11, 10, 11, 11, 11, 12, 12, 9, 8, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13,
 10, 9, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 9, 9, 8, 9, 9, 10, 11, 11, 12, 11, 12, 12, 13, 13, 13, 14, 10, 10, 9, 9, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 10, 10, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 15, 15, 10, 10, 10,
 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 10, 11, 10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 14, 13, 14, 13, 11, 11, 11, 10, 11, 12, 12, 12, 12, 13, 14, 14, 14, 15, 15, 14, 10, 12, 11, 11, 11, 12, 12, 13, 14, 14, 14, 14, 14, 14, 13, 14, 11, 12, 12,
 12, 12, 12, 13, 13, 13, 13, 15, 14, 14, 14, 14, 16, 11, 14, 12, 12, 12, 13, 13, 14, 14, 14, 16, 15, 15, 15, 17, 15, 11, 13, 13, 11, 12, 14, 14, 13, 14, 14, 15, 16, 15, 17, 15, 14, 11, 9, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8}; 
static const uint8 t24l_const[256]  = {4, 4, 6, 7, 8, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 9, 4, 4, 5, 6, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 8, 6, 5, 6, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 7, 7, 6, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 7, 8, 7, 7, 8,
 8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 7, 9, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 7, 9, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 7, 10, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 8, 10, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 
8, 10, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 8, 11, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 8, 11, 10, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 8, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 8, 11, 10, 10,
 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8, 12, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4}; 

const struct huffcodetab ht_const[HTN] =
{
{ 0, 0, 0,   0, NULL, NULL},
{ 2, 2, 0,   0, t1HB,  t1l},
{ 3, 3, 0,   0, t2HB,  t2l},
{ 3, 3, 0,   0, t3HB,  t3l},
{ 0, 0, 0,   0, NULL, NULL},// Apparently not used
{ 4, 4, 0,   0, t5HB,  t5l},
{ 4, 4, 0,   0, t6HB,  t6l},
{ 6, 6, 0,   0, t7HB,  t7l},
{ 6, 6, 0,   0, t8HB,  t8l},
{ 6, 6, 0,   0, t9HB,  t9l},
{ 8, 8, 0,   0,t10HB, t10l},
{ 8, 8, 0,   0,t11HB, t11l},
{ 8, 8, 0,   0,t12HB, t12l},
{16,16, 0,   0,t13HB, t13l},
{ 0, 0, 0,   0, NULL, NULL},// Apparently not used
{16,16, 0,   0,t15HB, t15l},
{16,16, 1,   1,t16HB, t16l},
{16,16, 2,   3,t16HB, t16l},
{16,16, 3,   7,t16HB, t16l},
{16,16, 4,  15,t16HB, t16l},
{16,16, 6,  63,t16HB, t16l},
{16,16, 8, 255,t16HB, t16l},
{16,16,10,1023,t16HB, t16l},
{16,16,13,8191,t16HB, t16l},
{16,16, 4,  15,t24HB, t24l},
{16,16, 5,  31,t24HB, t24l},
{16,16, 6,  63,t24HB, t24l},
{16,16, 7, 127,t24HB, t24l},
{16,16, 8, 255,t24HB, t24l},
{16,16, 9, 511,t24HB, t24l},
{16,16,11,2047,t24HB, t24l},
{16,16,13,8191,t24HB, t24l} };

const struct
{
  unsigned region0_count;
  unsigned region1_count;
} subdv_table[23] =
{ {0, 0}, /* 0 bands */
  {0, 0}, /* 1 bands */
  {0, 0}, /* 2 bands */
  {0, 0}, /* 3 bands */
  {0, 0}, /* 4 bands */
  {0, 1}, /* 5 bands */
  {1, 1}, /* 6 bands */
  {1, 1}, /* 7 bands */
  {1, 2}, /* 8 bands */
  {2, 2}, /* 9 bands */
  {2, 3}, /* 10 bands */
  {2, 3}, /* 11 bands */
  {3, 4}, /* 12 bands */
  {3, 4}, /* 13 bands */
  {3, 4}, /* 14 bands */
  {4, 5}, /* 15 bands */
  {4, 5}, /* 16 bands */
  {4, 6}, /* 17 bands */
  {5, 6}, /* 18 bands */
  {5, 6}, /* 19 bands */
  {5, 7}, /* 20 bands */
  {6, 7}, /* 21 bands */
  {6, 7}, /* 22 bands */
};

/* This is table B.9: coefficients for aliasing reduction */
static const int ca_int_const[8]  = {0xffffbe25,0xffffc39e,0xffffd7e3,0xffffe8b7,0xfffff3e5,0xfffffac2,0xfffffe2f,0xffffff87};
static const int cs_int_const[8]  = {0x00006dc2,0x000070dd,0x0000798d,0x00007ddd,0x00007f6d,0x00007fe4,0x00007ffd,0x00008000};
static const int win_int_const[18][36] = {
{ 0x0000006b,0x00000121,0x000001a7,0x000001f9,0x00000215,0x000001f9,0x000001a7,0x00000121,0x0000006b,0xffffff8b,0xfffffe87,0xfffffd68,0xfffffc35,0xfffffaf9,0xfffff9bd,0xfffff88b,0xfffff76b,0xfffff667,0xfffff587,0xfffff4d1,0xfffff44b,0xfffff3f8,0xfffff3dd,0xfffff3f8,0xfffff44b,0xfffff4d1,0xfffff587,0xfffff667,0xfffff76b,0xfffff88b,0xfffff9bd,0xfffffaf9,0xfffffc35,0xfffffd68,0xfffffe87,0xffffff8b,},
{ 0xffffff83,0xfffffe49,0xfffffcf3,0xfffffbc3,0xfffffaf9,0xfffffacb,0xfffffb5a,0xfffffcb0,0xfffffebf,0x0000015e,0x00000451,0x0000074d,0x00000a02,0x00000c23,0x00000d72,0x00000dc4,0x00000d06,0x00000b45,0x000008a6,0x00000565,0x000001cf,0xfffffe3b,0xfffffaf9,0xfffff853,0xfffff67c,0xfffff594,0xfffff59b,0xfffff67a,0xfffff801,0xfffff9f1,0xfffffc01,0xfffffdeb,0xffffff72,0x00000066,0x000000b5,0x00000060,},
{ 0xffffffab,0xffffffc2,0x000000ec,0x000002e3,0x00000507,0x0000068f,0x000006c7,0x00000545,0x00000214,0xfffffdbc,0xfffff922,0xfffff55d,0xfffff366,0xfffff3dd,0xfffff6d7,0xfffffbd4,0x000001d7,0x000007a2,0x00000bfb,0x00000dfa,0x00000d3e,0x00000a00,0x00000507,0xffffff74,0xfffffa77,0xfffff70d,0xfffff5c4,0xfffff69f,0xfffff922,0xfffffc79,0xffffffb7,0x00000215,0x00000327,0x000002ef,0x000001d7,0x00000085,},
{ 0x0000008c,0x000001d7,0x00000244,0x000000ec,0xfffffdeb,0xfffffa77,0xfffff85e,0xfffff922,0xfffffd1d,0x00000327,0x000008f3,0x00000bfb,0x00000aa3,0x00000507,0xfffffd11,0xfffff5c4,0xfffff206,0xfffff366,0xfffff971,0x000001d7,0x00000961,0x00000d3e,0x00000c23,0x000006c7,0xffffff7b,0xfffff922,0xfffff600,0xfffff6d7,0xfffffabb,0xffffffab,0x00000387,0x00000507,0x0000042c,0x00000214,0x0000003e,0xffffffb7,},
{ 0x0000003c,0xffffff4b,0xfffffd28,0xfffffc0d,0xfffffdeb,0x00000283,0x0000070f,0x000007ff,0x000003ad,0xfffffbfd,0xfffff594,0xfffff4ec,0xfffffb2d,0x00000507,0x00000c88,0x00000cd4,0x00000565,0xfffffa91,0xfffff2e0,0xfffff2fa,0xfffffab0,0x00000530,0x00000c23,0x00000ba7,0x00000497,0xfffffbaf,0xfffff650,0xfffff720,0xfffffcb0,0x000002ec,0x00000611,0x00000507,0x000001a2,0xfffffed3,0xfffffe49,0xffffff6e,},
{ 0xffffff69,0xfffffe87,0x00000022,0x0000039b,0x00000507,0x0000016b,0xfffffad7,0xfffff76b,0xfffffb91,0x000004d7,0x00000b2f,0x0000081a,0xfffffd46,0xfffff3dd,0xfffff490,0xffffff65,0x00000b2f,0x00000d8d,0x00000445,0xfffff76b,0xfffff221,0xfffff8b7,0x00000507,0x00000c50,0x000008d7,0xfffffe87,0xfffff6b3,0xfffff77b,0xfffffedf,0x000005a2,0x00000669,0x00000215,0xfffffdb4,0xfffffced,0xfffffedf,0x0000002f,},
{ 0xffffffde,0x00000179,0x000002ba,0xffffffd1,0xfffffaf9,0xfffffb29,0x0000024c,0x00000895,0x00000529,0xfffffa5e,0xfffff4d1,0xfffffc65,0x0000094d,0x00000c23,0x00000097,0xfffff3b0,0xfffff4d1,0x00000313,0x00000ddf,0x00000895,0xfffff997,0xfffff273,0xfffffaf9,0x00000885,0x00000b70,0x00000179,0xfffff729,0xfffff7e6,0x00000121,0x00000749,0x0000046f,0xfffffdeb,0xfffffbbb,0xfffffe95,0x00000121,0x0000009b,},
{ 0x0000009d,0x000000b5,0xfffffd8f,0xfffffc9c,0x00000215,0x00000682,0x000000ff,0xfffff801,0xfffffa27,0x00000662,0x00000a6c,0xfffffe70,0xfffff37f,0xfffffaf9,0x00000ac2,0x00000b04,0xfffffa9b,0xfffff1ea,0xfffffe26,0x00000d06,0x00000873,0xfffff7bf,0xfffff3dd,0x000001a5,0x00000be4,0x00000451,0xfffff7af,0xfffff861,0x00000350,0x00000793,0x000000db,0xfffffaf9,0xfffffd66,0x000001df,0x000001b7,0xffffffec,},
{ 0x00000006,0xfffffe29,0xffffff56,0x00000414,0x00000215,0xfffffa2d,0xfffffbe5,0x000006de,0x0000067d,0xfffff8eb,0xfffff70d,0x00000671,0x00000b30,0xfffffaf9,0xfffff311,0x00000301,0x00000dfa,0xffffff62,0xfffff1cf,0xfffffe29,0x00000d8e,0x00000414,0xfffff3dd,0xfffffa2d,0x00000a1d,0x000006de,0xfffff845,0xfffff8eb,0x00000545,0x00000671,0xfffffcf8,0xfffffaf9,0x00000149,0x00000301,0xffffffc2,0xffffff62,},
{ 0xffffff62,0x0000003e,0x00000301,0xfffffeb7,0xfffffaf9,0x00000308,0x00000671,0xfffffabb,0xfffff8eb,0x000007bb,0x000006de,0xfffff5e3,0xfffffa2d,0x00000c23,0x00000414,0xfffff272,0xfffffe29,0x00000e31,0xffffff62,0xfffff206,0x00000301,0x00000cef,0xfffffaf9,0xfffff4d0,0x00000671,0x000008f3,0xfffff8eb,0xfffff983,0x000006de,0x0000041b,0xfffffa2d,0xfffffdeb,0x00000414,0x000000aa,0xfffffe29,0xfffffffa,},
{ 0x00000014,0x000001b7,0xfffffe21,0xfffffd66,0x00000507,0x000000db,0xfffff86d,0x00000350,0x0000079f,0xfffff7af,0xfffffbaf,0x00000be4,0xfffffe5b,0xfffff3dd,0x00000841,0x00000873,0xfffff2fa,0xfffffe26,0x00000e16,0xfffffa9b,0xfffff4fc,0x00000ac2,0x00000507,0xfffff37f,0x00000190,0x00000a6c,0xfffff99e,0xfffffa27,0x000007ff,0x000000ff,0xfffff97e,0x00000215,0x00000364,0xfffffd8f,0xffffff4b,0x0000009d,},
{ 0x0000009b,0xfffffedf,0xfffffe95,0x00000445,0xfffffdeb,0xfffffb91,0x00000749,0xfffffedf,0xfffff7e6,0x000008d7,0x00000179,0xfffff490,0x00000885,0x00000507,0xfffff273,0x00000669,0x00000895,0xfffff221,0x00000313,0x00000b2f,0xfffff3b0,0xffffff69,0x00000c23,0xfffff6b3,0xfffffc65,0x00000b2f,0xfffffa5e,0xfffffad7,0x00000895,0xfffffdb4,0xfffffb29,0x00000507,0xffffffd1,0xfffffd46,0x00000179,0x00000022,},
{ 0xffffffd1,0xfffffedf,0x00000313,0xfffffdb4,0xfffffdeb,0x00000669,0xfffffa5e,0xfffffedf,0x00000885,0xfffff6b3,0x00000179,0x000008d7,0xfffff3b0,0x00000507,0x00000749,0xfffff221,0x00000895,0x00000445,0xfffff273,0x00000b2f,0x0000009b,0xfffff490,0x00000c23,0xfffffd46,0xfffff7e6,0x00000b2f,0xfffffb29,0xfffffb91,0x00000895,0xfffffad7,0xfffffe95,0x00000507,0xfffffc65,0x00000022,0x00000179,0xffffff69,},
{ 0xffffff6e,0x000001b7,0xfffffed3,0xfffffe5e,0x00000507,0xfffff9ef,0x000002ec,0x00000350,0xfffff720,0x000009b0,0xfffffbaf,0xfffffb69,0x00000ba7,0xfffff3dd,0x00000530,0x00000550,0xfffff2fa,0x00000d20,0xfffffa91,0xfffffa9b,0x00000cd4,0xfffff378,0x00000507,0x000004d3,0xfffff4ec,0x00000a6c,0xfffffbfd,0xfffffc53,0x000007ff,0xfffff8f1,0x00000283,0x00000215,0xfffffc0d,0x000002d8,0xffffff4b,0xffffffc4,},
{ 0x00000049,0x0000003e,0xfffffdec,0x0000042c,0xfffffaf9,0x00000387,0x00000055,0xfffffabb,0x00000929,0xfffff600,0x000006de,0xffffff7b,0xfffff939,0x00000c23,0xfffff2c2,0x00000961,0xfffffe29,0xfffff971,0x00000c9a,0xfffff206,0x00000a3c,0xfffffd11,0xfffffaf9,0x00000aa3,0xfffff405,0x000008f3,0xfffffcd9,0xfffffd1d,0x000006de,0xfffff85e,0x00000589,0xfffffdeb,0xffffff14,0x00000244,0xfffffe29,0x0000008c,},
{ 0x00000085,0xfffffe29,0x000002ef,0xfffffcd9,0x00000215,0x00000049,0xfffffc79,0x000006de,0xfffff69f,0x00000a3c,0xfffff70d,0x00000589,0xffffff74,0xfffffaf9,0x00000a00,0xfffff2c2,0x00000dfa,0xfffff405,0x000007a2,0xfffffe29,0xfffffbd4,0x00000929,0xfffff3dd,0x00000c9a,0xfffff55d,0x000006de,0xfffffdbc,0xfffffdec,0x00000545,0xfffff939,0x0000068f,0xfffffaf9,0x000002e3,0xffffff14,0xffffffc2,0x00000055,},
{ 0xffffffa0,0x000000b5,0xffffff9a,0xffffff72,0x00000215,0xfffffc01,0x0000060f,0xfffff801,0x00000986,0xfffff59b,0x00000a6c,0xfffff67c,0x000007ad,0xfffffaf9,0x000001c5,0x000001cf,0xfffffa9b,0x000008a6,0xfffff4bb,0x00000d06,0xfffff23c,0x00000d72,0xfffff3dd,0x00000a02,0xfffff8b3,0x00000451,0xfffffea2,0xfffffebf,0x00000350,0xfffffb5a,0x00000535,0xfffffaf9,0x0000043d,0xfffffcf3,0x000001b7,0xffffff83,},
{ 0xffffff8b,0x00000179,0xfffffd68,0x000003cb,0xfffffaf9,0x00000643,0xfffff88b,0x00000895,0xfffff667,0x00000a79,0xfffff4d1,0x00000bb5,0xfffff3f8,0x00000c23,0xfffff3f8,0x00000bb5,0xfffff4d1,0x00000a79,0xfffff667,0x00000895,0xfffff88b,0x00000643,0xfffffaf9,0x000003cb,0xfffffd68,0x00000179,0xffffff8b,0xffffff95,0x00000121,0xfffffe59,0x000001f9,0xfffffdeb,0x000001f9,0xfffffe59,0x00000121,0xffffff95,}};

const short filter_int_const[SBLIMIT][64] = {
{  23170, 24279, 25330, 26320, 27246, 28106, 28899, 29622, 30274, 30853, 31357, 31786, 32138, 32413, 32610, 32729, 32767, 32729, 32610, 32413, 32138, 31786, 31357, 30853, 30274, 29622, 28899, 28106, 27246, 26320, 25330, 24279, 23170, 22006, 20788, 19520, 18205, 16846, 15447, 14010, 12540, 11039,  9512,  7962,  6393,  4808,  3212,  1608,     0, -1607, -3211, -4807, -6392, -7961, -9511,-11038,-12539,-14009,-15446,-16845,-18204,-19519,-20787,-22005, },
{ -23169,-19519,-15446,-11038, -6392, -1607,  3212,  7962, 12540, 16846, 20788, 24279, 27246, 29622, 31357, 32413, 32767, 32413, 31357, 29622, 27246, 24279, 20788, 16846, 12540,  7962,  3212, -1607, -6392,-11038,-15446,-19519,-23169,-26319,-28898,-30852,-32137,-32728,-32609,-31785,-30273,-28105,-25329,-22005,-18204,-14009, -9511, -4807,     0,  4808,  9512, 14010, 18205, 22006, 25330, 28106, 30274, 31786, 32610, 32729, 32138, 30853, 28899, 26320, },
{ -23169,-28105,-31356,-32728,-32137,-29621,-25329,-19519,-12539, -4807,  3212, 11039, 18205, 24279, 28899, 31786, 32767, 31786, 28899, 24279, 18205, 11039,  3212, -4807,-12539,-19519,-25329,-29621,-32137,-32728,-31356,-28105,-23169,-16845, -9511, -1607,  6393, 14010, 20788, 26320, 30274, 32413, 32610, 30853, 27246, 22006, 15447,  7962,     0, -7961,-15446,-22005,-27245,-30852,-32609,-32412,-30273,-26319,-20787,-14009, -6392,  1608,  9512, 16846, },
{  23170, 14010,  3212, -7961,-18204,-26319,-31356,-32728,-30273,-24278,-15446, -4807,  6393, 16846, 25330, 30853, 32767, 30853, 25330, 16846,  6393, -4807,-15446,-24278,-30273,-32728,-31356,-26319,-18204, -7961,  3212, 14010, 23170, 29622, 32610, 31786, 27246, 19520,  9512, -1607,-12539,-22005,-28898,-32412,-32137,-28105,-20787,-11038,     0, 11039, 20788, 28106, 32138, 32413, 28899, 22006, 12540,  1608, -9511,-19519,-27245,-31785,-32609,-29621, },
{  23170, 30853, 32610, 28106, 18205,  4808, -9511,-22005,-30273,-32728,-28898,-19519, -6392,  7962, 20788, 29622, 32767, 29622, 20788,  7962, -6392,-19519,-28898,-32728,-30273,-22005, -9511,  4808, 18205, 28106, 32610, 30853, 23170, 11039, -3211,-16845,-27245,-32412,-31356,-24278,-12539,  1608, 15447, 26320, 32138, 31786, 25330, 14010,     0,-14009,-25329,-31785,-32137,-26319,-15446, -1607, 12540, 24279, 31357, 32413, 27246, 16846,  3212,-11038, },
{ -23169, -7961,  9512, 24279, 32138, 30853, 20788,  4808,-12539,-26319,-32609,-29621,-18204, -1607, 15447, 28106, 32767, 28106, 15447, -1607,-18204,-29621,-32609,-26319,-12539,  4808, 20788, 30853, 32138, 24279,  9512, -7961,-23169,-31785,-31356,-22005, -6392, 11039, 25330, 32413, 30274, 19520,  3212,-14009,-27245,-32728,-28898,-16845,     0, 16846, 28899, 32729, 27246, 14010, -3211,-19519,-30273,-32412,-25329,-11038,  6393, 22006, 31357, 31786, },
{ -23169,-32412,-28898,-14009,  6393, 24279, 32610, 28106, 12540, -7961,-25329,-32728,-27245,-11038,  9512, 26320, 32767, 26320,  9512,-11038,-27245,-32728,-25329, -7961, 12540, 28106, 32610, 24279,  6393,-14009,-28898,-32412,-23169, -4807, 15447, 29622, 32138, 22006,  3212,-16845,-30273,-31785,-20787, -1607, 18205, 30853, 31357, 19520,     0,-19519,-31356,-30852,-18204,  1608, 20788, 31786, 30274, 16846, -3211,-22005,-32137,-29621,-15446,  4808, },
{  23170,  1608,-20787,-32412,-27245, -7961, 15447, 30853, 30274, 14010, -9511,-28105,-32137,-19519,  3212, 24279, 32767, 24279,  3212,-19519,-32137,-28105, -9511, 14010, 30274, 30853, 15447, -7961,-27245,-32412,-20787,  1608, 23170, 32729, 25330,  4808,-18204,-31785,-28898,-11038, 12540, 29622, 31357, 16846, -6392,-26319,-32609,-22005,     0, 22006, 32610, 26320,  6393,-16845,-31356,-29621,-12539, 11039, 28899, 31786, 18205, -4807,-25329,-32728, },
{  23170, 32729, 20788, -4807,-27245,-31785,-15446, 11039, 30274, 29622,  9512,-16845,-32137,-26319, -3211, 22006, 32767, 22006, -3211,-26319,-32137,-16845,  9512, 29622, 30274, 11039,-15446,-31785,-27245, -4807, 20788, 32729, 23170, -1607,-25329,-32412,-18204,  7962, 28899, 30853, 12540,-14009,-31356,-28105, -6392, 19520, 32610, 24279,     0,-24278,-32609,-19519,  6393, 28106, 31357, 14010,-12539,-30852,-28898, -7961, 18205, 32413, 25330,  1608, },
{ -23169,  4808, 28899, 29622,  6393,-22005,-32609,-16845, 12540, 31786, 25330, -1607,-27245,-30852, -9511, 19520, 32767, 19520, -9511,-30852,-27245, -1607, 25330, 31786, 12540,-16845,-32609,-22005,  6393, 29622, 28899,  4808,-23169,-32412,-15446, 14010, 32138, 24279, -3211,-28105,-30273, -7961, 20788, 32729, 18205,-11038,-31356,-26319,     0, 26320, 31357, 11039,-18204,-32728,-20787,  7962, 30274, 28106,  3212,-24278,-32137,-14009, 15447, 32413, },
{ -23169,-31785, -9511, 22006, 32138, 11039,-20787,-32412,-12539, 19520, 32610, 14010,-18204,-32728,-15446, 16846, 32767, 16846,-15446,-32728,-18204, 14010, 32610, 19520,-12539,-32412,-20787, 11039, 32138, 22006, -9511,-31785,-23169,  7962, 31357, 24279, -6392,-30852,-25329,  4808, 30274, 26320, -3211,-29621,-27245,  1608, 28899, 28106,     0,-28105,-28898, -1607, 27246, 29622,  3212,-26319,-30273, -4807, 25330, 30853,  6393,-24278,-31356, -7961, },
{  23170,-11038,-32609,-16845, 18205, 32413,  9512,-24278,-30273, -1607, 28899, 26320, -6392,-31785,-20787, 14010, 32767, 14010,-20787,-31785, -6392, 26320, 28899, -1607,-30273,-24278,  9512, 32413, 18205,-16845,-32609,-11038, 23170, 30853,  3212,-28105,-27245,  4808, 31357, 22006,-12539,-32728,-15446, 19520, 32138,  7962,-25329,-29621,     0, 29622, 25330, -7961,-32137,-19519, 15447, 32729, 12540,-22005,-31356, -4807, 27246, 28106, -3211,-30852, },
{  23170, 29622, -3211,-31785,-18204, 19520, 31357,  1608,-30273,-22005, 15447, 32413,  6393,-28105,-25329, 11039, 32767, 11039,-25329,-28105,  6393, 32413, 15447,-22005,-30273,  1608, 31357, 19520,-18204,-31785, -3211, 29622, 23170,-14009,-32609, -7961, 27246, 26320, -9511,-32728,-12539, 24279, 28899, -4807,-32137,-16845, 20788, 30853,     0,-30852,-20787, 16846, 32138,  4808,-28898,-24278, 12540, 32729,  9512,-26319,-27245,  7962, 32610, 14010, },
{ -23169, 16846, 31357, -1607,-32137,-14009, 25330, 26320,-12539,-32412, -3211, 30853, 18205,-22005,-28898,  7962, 32767,  7962,-28898,-22005, 18205, 30853, -3211,-32412,-12539, 26320, 25330,-14009,-32137, -1607, 31357, 16846,-23169,-28105,  9512, 32729,  6393,-29621,-20787, 19520, 30274, -4807,-32609,-11038, 27246, 24279,-15446,-31785,     0, 31786, 15447,-24278,-27245, 11039, 32610,  4808,-30273,-19519, 20788, 29622, -6392,-32728, -9511, 28106, },
{ -23169,-26319, 15447, 30853, -6392,-32728, -3211, 31786, 12540,-28105,-20787, 22006, 27246,-14009,-31356,  4808, 32767,  4808,-31356,-14009, 27246, 22006,-20787,-28105, 12540, 31786, -3211,-32728, -6392, 30853, 15447,-26319,-23169, 19520, 28899,-11038,-32137,  1608, 32610,  7962,-30273,-16845, 25330, 24279,-18204,-29621,  9512, 32413,     0,-32412, -9511, 29622, 18205,-24278,-25329, 16846, 30274, -7961,-32609, -1607, 32138, 11039,-28898,-19519, },
{  23170,-22005,-25329, 19520, 27246,-16845,-28898, 14010, 30274,-11038,-31356,  7962, 32138, -4807,-32609,  1608, 32767,  1608,-32609, -4807, 32138,  7962,-31356,-11038, 30274, 14010,-28898,-16845, 27246, 19520,-25329,-22005, 23170, 24279,-20787,-26319, 18205, 28106,-15446,-29621, 12540, 30853, -9511,-31785,  6393, 32413, -3211,-32728,     0, 32729,  3212,-32412, -6392, 31786,  9512,-30852,-12539, 29622, 15447,-28105,-18204, 26320, 20788,-24278, },
{  23170, 22006,-25329,-19519, 27246, 16846,-28898,-14009, 30274, 11039,-31356, -7961, 32138,  4808,-32609, -1607, 32767, -1607,-32609,  4808, 32138, -7961,-31356, 11039, 30274,-14009,-28898, 16846, 27246,-19519,-25329, 22006, 23170,-24278,-20787, 26320, 18205,-28105,-15446, 29622, 12540,-30852, -9511, 31786,  6393,-32412, -3211, 32729,     0,-32728,  3212, 32413, -6392,-31785,  9512, 30853,-12539,-29621, 15447, 28106,-18204,-26319, 20788, 24279, },
{ -23169, 26320, 15447,-30852, -6392, 32729, -3211,-31785, 12540, 28106,-20787,-22005, 27246, 14010,-31356, -4807, 32767, -4807,-31356, 14010, 27246,-22005,-20787, 28106, 12540,-31785, -3211, 32729, -6392,-30852, 15447, 26320,-23169,-19519, 28899, 11039,-32137, -1607, 32610, -7961,-30273, 16846, 25330,-24278,-18204, 29622,  9512,-32412,     0, 32413, -9511,-29621, 18205, 24279,-25329,-16845, 30274,  7962,-32609,  1608, 32138,-11038,-28898, 19520, },
{ -23169,-16845, 31357,  1608,-32137, 14010, 25330,-26319,-12539, 32413, -3211,-30852, 18205, 22006,-28898, -7961, 32767, -7961,-28898, 22006, 18205,-30852, -3211, 32413,-12539,-26319, 25330, 14010,-32137,  1608, 31357,-16845,-23169, 28106,  9512,-32728,  6393, 29622,-20787,-19519, 30274,  4808,-32609, 11039, 27246,-24278,-15446, 31786,     0,-31785, 15447, 24279,-27245,-11038, 32610, -4807,-30273, 19520, 20788,-29621, -6392, 32729, -9511,-28105, },
{  23170,-29621, -3211, 31786,-18204,-19519, 31357, -1607,-30273, 22006, 15447,-32412,  6393, 28106,-25329,-11038, 32767,-11038,-25329, 28106,  6393,-32412, 15447, 22006,-30273, -1607, 31357,-19519,-18204, 31786, -3211,-29621, 23170, 14010,-32609,  7962, 27246,-26319, -9511, 32729,-12539,-24278, 28899,  4808,-32137, 16846, 20788,-30852,     0, 30853,-20787,-16845, 32138, -4807,-28898, 24279, 12540,-32728,  9512, 26320,-27245, -7961, 32610,-14009, },
{  23170, 11039,-32609, 16846, 18205,-32412,  9512, 24279,-30273,  1608, 28899,-26319, -6392, 31786,-20787,-14009, 32767,-14009,-20787, 31786, -6392,-26319, 28899,  1608,-30273, 24279,  9512,-32412, 18205, 16846,-32609, 11039, 23170,-30852,  3212, 28106,-27245, -4807, 31357,-22005,-12539, 32729,-15446,-19519, 32138, -7961,-25329, 29622,     0,-29621, 25330,  7962,-32137, 19520, 15447,-32728, 12540, 22006,-31356,  4808, 27246,-28105, -3211, 30853, },
{ -23169, 31786, -9511,-22005, 32138,-11038,-20787, 32413,-12539,-19519, 32610,-14009,-18204, 32729,-15446,-16845, 32767,-16845,-15446, 32729,-18204,-14009, 32610,-19519,-12539, 32413,-20787,-11038, 32138,-22005, -9511, 31786,-23169, -7961, 31357,-24278, -6392, 30853,-25329, -4807, 30274,-26319, -3211, 29622,-27245, -1607, 28899,-28105,     0, 28106,-28898,  1608, 27246,-29621,  3212, 26320,-30273,  4808, 25330,-30852,  6393, 24279,-31356,  7962, },
{ -23169, -4807, 28899,-29621,  6393, 22006,-32609, 16846, 12540,-31785, 25330,  1608,-27245, 30853, -9511,-19519, 32767,-19519, -9511, 30853,-27245,  1608, 25330,-31785, 12540, 16846,-32609, 22006,  6393,-29621, 28899, -4807,-23169, 32413,-15446,-14009, 32138,-24278, -3211, 28106,-30273,  7962, 20788,-32728, 18205, 11039,-31356, 26320,     0,-26319, 31357,-11038,-18204, 32729,-20787, -7961, 30274,-28105,  3212, 24279,-32137, 14010, 15447,-32412, },
{  23170,-32728, 20788,  4808,-27245, 31786,-15446,-11038, 30274,-29621,  9512, 16846,-32137, 26320, -3211,-22005, 32767,-22005, -3211, 26320,-32137, 16846,  9512,-29621, 30274,-11038,-15446, 31786,-27245,  4808, 20788,-32728, 23170,  1608,-25329, 32413,-18204, -7961, 28899,-30852, 12540, 14010,-31356, 28106, -6392,-19519, 32610,-24278,     0, 24279,-32609, 19520,  6393,-28105, 31357,-14009,-12539, 30853,-28898,  7962, 18205,-32412, 25330, -1607, },
{  23170, -1607,-20787, 32413,-27245,  7962, 15447,-30852, 30274,-14009, -9511, 28106,-32137, 19520,  3212,-24278, 32767,-24278,  3212, 19520,-32137, 28106, -9511,-14009, 30274,-30852, 15447,  7962,-27245, 32413,-20787, -1607, 23170,-32728, 25330, -4807,-18204, 31786,-28898, 11039, 12540,-29621, 31357,-16845, -6392, 26320,-32609, 22006,     0,-22005, 32610,-26319,  6393, 16846,-31356, 29622,-12539,-11038, 28899,-31785, 18205,  4808,-25329, 32729, },
{ -23169, 32413,-28898, 14010,  6393,-24278, 32610,-28105, 12540,  7962,-25329, 32729,-27245, 11039,  9512,-26319, 32767,-26319,  9512, 11039,-27245, 32729,-25329,  7962, 12540,-28105, 32610,-24278,  6393, 14010,-28898, 32413,-23169,  4808, 15447,-29621, 32138,-22005,  3212, 16846,-30273, 31786,-20787,  1608, 18205,-30852, 31357,-19519,     0, 19520,-31356, 30853,-18204, -1607, 20788,-31785, 30274,-16845, -3211, 22006,-32137, 29622,-15446, -4807, },
{ -23169,  7962,  9512,-24278, 32138,-30852, 20788, -4807,-12539, 26320,-32609, 29622,-18204,  1608, 15447,-28105, 32767,-28105, 15447,  1608,-18204, 29622,-32609, 26320,-12539, -4807, 20788,-30852, 32138,-24278,  9512,  7962,-23169, 31786,-31356, 22006, -6392,-11038, 25330,-32412, 30274,-19519,  3212, 14010,-27245, 32729,-28898, 16846,     0,-16845, 28899,-32728, 27246,-14009, -3211, 19520,-30273, 32413,-25329, 11039,  6393,-22005, 31357,-31785, },
{  23170,-30852, 32610,-28105, 18205, -4807, -9511, 22006,-30273, 32729,-28898, 19520, -6392, -7961, 20788,-29621, 32767,-29621, 20788, -7961, -6392, 19520,-28898, 32729,-30273, 22006, -9511, -4807, 18205,-28105, 32610,-30852, 23170,-11038, -3211, 16846,-27245, 32413,-31356, 24279,-12539, -1607, 15447,-26319, 32138,-31785, 25330,-14009,     0, 14010,-25329, 31786,-32137, 26320,-15446,  1608, 12540,-24278, 31357,-32412, 27246,-16845,  3212, 11039, },
{  23170,-14009,  3212,  7962,-18204, 26320,-31356, 32729,-30273, 24279,-15446,  4808,  6393,-16845, 25330,-30852, 32767,-30852, 25330,-16845,  6393,  4808,-15446, 24279,-30273, 32729,-31356, 26320,-18204,  7962,  3212,-14009, 23170,-29621, 32610,-31785, 27246,-19519,  9512,  1608,-12539, 22006,-28898, 32413,-32137, 28106,-20787, 11039,     0,-11038, 20788,-28105, 32138,-32412, 28899,-22005, 12540, -1607, -9511, 19520,-27245, 31786,-32609, 29622, },
{ -23169, 28106,-31356, 32729,-32137, 29622,-25329, 19520,-12539,  4808,  3212,-11038, 18205,-24278, 28899,-31785, 32767,-31785, 28899,-24278, 18205,-11038,  3212,  4808,-12539, 19520,-25329, 29622,-32137, 32729,-31356, 28106,-23169, 16846, -9511,  1608,  6393,-14009, 20788,-26319, 30274,-32412, 32610,-30852, 27246,-22005, 15447, -7961,     0,  7962,-15446, 22006,-27245, 30853,-32609, 32413,-30273, 26320,-20787, 14010, -6392, -1607,  9512,-16845, },
{ -23169, 19520,-15446, 11039, -6392,  1608,  3212, -7961, 12540,-16845, 20788,-24278, 27246,-29621, 31357,-32412, 32767,-32412, 31357,-29621, 27246,-24278, 20788,-16845, 12540, -7961,  3212,  1608, -6392, 11039,-15446, 19520,-23169, 26320,-28898, 30853,-32137, 32729,-32609, 31786,-30273, 28106,-25329, 22006,-18204, 14010, -9511,  4808,     0, -4807,  9512,-14009, 18205,-22005, 25330,-28105, 30274,-31785, 32610,-32728, 32138,-30852, 28899,-26319, },
{  23170,-24278, 25330,-26319, 27246,-28105, 28899,-29621, 30274,-30852, 31357,-31785, 32138,-32412, 32610,-32728, 32767,-32728, 32610,-32412, 32138,-31785, 31357,-30852, 30274,-29621, 28899,-28105, 27246,-26319, 25330,-24278, 23170,-22005, 20788,-19519, 18205,-16845, 15447,-14009, 12540,-11038,  9512, -7961,  6393, -4807,  3212, -1607,     0,  1608, -3211,  4808, -6392,  7962, -9511, 11039,-12539, 14010,-15446, 16846,-18204, 19520,-20787, 22006, } };

const int sfBandIndex[6][23] =
{
/* Table B.2.b: 22.05 kHz */
{0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
/* Table B.2.c: 24 kHz */
{0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,330,394,464,540,576},
/* Table B.2.a: 16 kHz */
{0,6,12,18,24,30,36,44,45,66,80,96,116,140,168,200,238,248,336,396,464,522,576},
/* Table B.8.b: 44.1 kHz */
{0,4, 8,12,16,20,24,30,36,44,52,62, 74, 90,110,134,162,196,238,288,342,418,576},
/* Table B.8.c: 48 kHz */
{0,4, 8,12,16,20,24,30,36,42,50,60, 72, 88,106,128,156,190,230,276,330,384,576},
/* Table B.8.a: 32 kHz */
{0,4, 8,12,16,20,24,30,36,44,54,66, 82,102,126,156,194,240,296,364,448,550,576} };

const unsigned short enwindow_int_const[512] = {
0x0000,0x0035,0x01fd,0x066c,0x4948,0x066c,0x01fd,0x0035,0x0000,0x0037,0x01f4,0x05d2,0x493c,0x06f8,0x0204,0x0034,
0x0000,0x0038,0x01e8,0x052a,0x491a,0x0776,0x0208,0x0032,0x0000,0x0038,0x01d9,0x0474,0x48e1,0x07e7,0x020a,0x0031,
0x0000,0x0039,0x01c8,0x03b0,0x4892,0x084b,0x0209,0x0030,0x0000,0x0039,0x01b3,0x02de,0x482d,0x08a2,0x0207,0x002e,
0x0000,0x0039,0x019b,0x01fd,0x47b2,0x08ed,0x0202,0x002c,0x0000,0x0039,0x0180,0x010f,0x4721,0x092b,0x01fc,0x002a,
0x0000,0x0038,0x0161,0x0011,0x467a,0x095e,0x01f4,0x0028,0x0000,0x0037,0x0140,0xff07,0x45bf,0x0985,0x01eb,0x0026,
0x0000,0x0036,0x011b,0xfdee,0x44f0,0x09a2,0x01e0,0x0025,0x0000,0x0034,0x00f3,0xfcc8,0x440c,0x09b4,0x01d4,0x0023,
0x0000,0x0032,0x00c7,0xfb93,0x4315,0x09bb,0x01c6,0x0021,0x0000,0x002f,0x0097,0xfa53,0x420b,0x09ba,0x01b8,0x001f,
0x0000,0x002c,0x0065,0xf905,0x40f0,0x09af,0x01a9,0x001d,0x0000,0x0029,0x002e,0xf7aa,0x3fc3,0x099b,0x0198,0x001c,
0x0000,0x0025,0xfff6,0xf643,0x3e85,0x0980,0x0188,0x001a,0xffff,0x0020,0xffb9,0xf4d1,0x3d37,0x095c,0x0176,0x0018,
0xffff,0x001b,0xff79,0xf354,0x3bda,0x0932,0x0165,0x0017,0xffff,0x0015,0xff36,0xf1cc,0x3a70,0x0901,0x0153,0x0015,
0xffff,0x000e,0xfeef,0xf03a,0x38f7,0x08ca,0x0141,0x0014,0xffff,0x0007,0xfea6,0xee9f,0x3773,0x088d,0x012f,0x0012,
0xfffe,0x0000,0xfe5a,0xecfb,0x35e3,0x084b,0x011c,0x0011,0xfffe,0xfff8,0xfe0b,0xeb50,0x3447,0x0804,0x010a,0x0010,
0xfffe,0xffef,0xfdbb,0xe99d,0x32a3,0x07ba,0x00f8,0x000f,0xfffd,0xffe5,0xfd67,0xe7e4,0x30f6,0x076b,0x00e6,0x000d,
0xfffd,0xffdb,0xfd12,0xe624,0x2f41,0x071a,0x00d4,0x000c,0xfffd,0xffd0,0xfcbb,0xe461,0x2d86,0x06c6,0x00c3,0x000b,
0xfffc,0xffc4,0xfc63,0xe299,0x2bc5,0x066f,0x00b2,0x000a,0xfffc,0xffb8,0xfc09,0xe0ce,0x2a00,0x0617,0x00a1,0x0009,
0xfffb,0xffaa,0xfbaf,0xdf01,0x2836,0x05be,0x0091,0x0009,0xfffb,0xff9d,0xfb54,0xdd33,0x266a,0x0563,0x0081,0x0008,
0xfffa,0xff8e,0xfaf9,0xdb65,0x249c,0x0508,0x0073,0x0007,0xfff9,0xff80,0xfa9e,0xd997,0x22ce,0x04ad,0x0064,0x0006,
0xfff8,0xff70,0xfa43,0xd7cb,0x2100,0x0452,0x0057,0x0006,0xfff8,0xff60,0xf9ea,0xd601,0x1f33,0x03f8,0x0049,0x0005,
0xfff7,0xff4f,0xf992,0xd43c,0x1d68,0x039e,0x003d,0x0005,0xfff6,0xff3e,0xf93b,0xd27b,0x1ba0,0x0346,0x0031,0x0004,
0xfff5,0xff2d,0xf8e7,0xd0c0,0x19dd,0x02ef,0x0026,0x0004,0xfff4,0xff1b,0xf896,0xcf0b,0x181d,0x029a,0x001c,0x0004,
0xfff2,0xff09,0xf847,0xcd5e,0x1664,0x0246,0x0012,0x0003,0xfff1,0xfef7,0xf7fd,0xcbba,0x14b1,0x01f6,0x0009,0x0003,
0xfff0,0xfee5,0xf7b6,0xca1e,0x1306,0x01a7,0x0001,0x0003,0xffef,0xfed2,0xf774,0xc88e,0x1162,0x015b,0xfffa,0x0002,
0xffed,0xfec0,0xf737,0xc70a,0x0fc7,0x0112,0xfff3,0x0002,0xffec,0xfeae,0xf700,0xc591,0x0e35,0x00cb,0xffec,0x0002,
0xffea,0xfe9c,0xf6cf,0xc427,0x0cad,0x0088,0xffe6,0x0002,0xffe9,0xfe8b,0xf6a5,0xc2ca,0x0b30,0x0048,0xffe1,0x0002,
0xffe7,0xfe79,0xf681,0xc17c,0x09be,0x000b,0xffdc,0x0001,0xffe5,0xfe69,0xf666,0xc03e,0x0857,0xffd3,0xffd8,0x0001,
0xffe4,0xfe58,0xf652,0xbf11,0x06fc,0xff9c,0xffd5,0x0001,0xffe2,0xfe49,0xf647,0xbdf6,0x05ae,0xff6a,0xffd2,0x0001,
0xffe0,0xfe3b,0xf646,0xbcec,0x046e,0xff3a,0xffcf,0x0001,0xffde,0xfe2d,0xf64d,0xbbf5,0x0339,0xff0e,0xffcd,0x0001,
0xffdc,0xfe21,0xf65f,0xbb11,0x0213,0xfee6,0xffcb,0x0001,0xffdb,0xfe16,0xf67c,0xba42,0x00fa,0xfec1,0xffca,0x0001,
0xffd9,0xfe0d,0xf6a3,0xb987,0xfff0,0xfea0,0xffc9,0x0001,0xffd7,0xfe05,0xf6d6,0xb8e0,0xfef2,0xfe81,0xffc8,0x0001,
0xffd5,0xfdff,0xf714,0xb84f,0xfe04,0xfe66,0xffc8,0x0000,0xffd3,0xfdfa,0xf75f,0xb7d4,0xfd23,0xfe4e,0xffc8,0x0000,
0xffd1,0xfdf8,0xf7b6,0xb76f,0xfc51,0xfe39,0xffc8,0x0000,0xffd0,0xfdf7,0xf81a,0xb720,0xfb8d,0xfe28,0xffc9,0x0000,
0xffcf,0xfdf9,0xf88b,0xb6e7,0xfad7,0xfe19,0xffc9,0x0000,0xffcd,0xfdfd,0xf909,0xb6c5,0xfa2f,0xfe0d,0xffca,0x0000,
};

const uint8 int2idx_const[4096] = {
  0,  0,  1,  1,  1,  1,  1,  2,  2,  2,  2,  2,  2,  2,  3,  3,  3,  3,  3,  3,  3,  3,  4,  4,  4,  4,  4,  4,  4,  4,  5,  5,
  5,  5,  5,  5,  5,  5,  5,  5,  6,  6,  6,  6,  6,  6,  6,  6,  6,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,
  8,  8,  8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23,
 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27,
 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29,
 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31,
 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32,
 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,
 34, 34, 34, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36,
 36, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 38, 38,
 38, 38, 38, 38, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40, 40, 40,
 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43, 43,
 43, 43, 43, 43, 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 45, 45, 45, 45, 45, 45, 45, 45,
 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 46, 47, 47,
 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
 48, 48, 48, 48, 48, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 50, 50, 50, 50, 50, 50, 50,
 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51,
 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53,
 53, 53, 53, 53, 53, 53, 53, 53, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 54, 55, 55, 55, 55,
 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56,
 56, 56, 56, 56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 58, 58, 58, 58, 58, 58, 58,
 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
 59, 59, 59, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 61, 61, 61, 61, 61,
 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62, 62,
 62, 62, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64, 64,
 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
 65, 65, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 66, 67, 67, 67, 67, 67, 67, 67, 67,
 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,
 68, 68, 68, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 70, 70, 70, 70, 70, 70, 70,
 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71,
 71, 71, 71, 71, 71, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 73, 73, 73, 73, 73,
 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,
 74, 74, 74, 74, 74, 74, 74, 74, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 76, 76,
 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 76, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78, 78,
 78, 78, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 79, 80, 80, 80, 80, 80, 80, 80,
 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 80, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81,
 81, 81, 81, 81, 81, 81, 81, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 82, 83,
 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 83, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84,
 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 84, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
 85, 85, 85, 85, 85, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 87, 87, 87, 87,
 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88,
 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 88, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89,
 89, 89, 89, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 91, 91, 91, 91, 91,
 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,
 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93,
 93, 93, 93, 93, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 95, 95, 95, 95,
 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 95, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,
 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97, 97,
 97, 97, 97, 97, 97, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 99, 99,
 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,100,100,100,100,100,100,100,100,100,100,
100,100,100,100,100,100,100,100,100,100,100,100,100,100,100,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,101,
101,101,101,101,101,101,101,101,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,102,
102,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,103,104,104,104,104,104,104,
104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,104,105,105,105,105,105,105,105,105,105,105,105,105,105,
105,105,105,105,105,105,105,105,105,105,105,105,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,106,
106,106,106,106,106,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,108,
108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,108,109,109,109,109,109,109,109,109,
109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,110,110,110,110,110,110,110,110,110,110,110,110,110,110,
110,110,110,110,110,110,110,110,110,110,110,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,
111,111,111,111,111,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,112,113,
113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,113,114,114,114,114,114,114,114,114,
114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,115,115,115,115,115,115,115,115,115,115,115,115,115,115,
115,115,115,115,115,115,115,115,115,115,115,115,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,
116,116,116,116,116,116,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,117,
118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,118,119,119,119,119,119,119,
119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,119,120,120,120,120,120,120,120,120,120,120,120,
120,120,120,120,120,120,120,120,120,120,120,120,120,120,120,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,121,
121,121,121,121,121,121,121,121,121,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,122,
122,122,122,122,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,124,124,
124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,125,125,125,125,125,125,125,
125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,125,126,126,126,126,126,126,126,126,126,126,126,126,
126,126,126,126,126,126,126,126,126,126,126,126,126,126,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,
127,127,127,127,127,127,127,127,127,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,
128,128,128,128,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,130,
130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,130,131,131,131,131,131,131,
131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,132,132,132,132,132,132,132,132,132,132,132,
132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,133,
133,133,133,133,133,133,133,133,133,133,133,133,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,
134,134,134,134,134,134,134,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,135,
135,135,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,136,137,137,
137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,137,138,138,138,138,138,138,138,
138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,138,139,139,139,139,139,139,139,139,139,139,139,
139,139,139,139,139,139,139,139,139,139,139,139,139,139,139,139,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,140,
140,140,140,140,140,140,140,140,140,140,140,140,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,141,
141,141,141,141,141,141,141,141,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,142,
142,142,142,142,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,144,
144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,144,145,145,145,145,145,
145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,146,146,146,146,146,146,146,146,146,
146,146,146,146,146,146,146,146,146,146,146,146,146,146,146,146,146,146,146,146,147,147,147,147,147,147,147,147,147,147,147,147,
147,147,147,147,147,147,147,147,147,147,147,147,147,147,147,147,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,
148,148,148,148,148,148,148,148,148,148,148,148,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,
149,149,149,149,149,149,149,149,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,
150,150,150,150,150,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,151,
151,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,153,153,153,
153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,153,154,154,154,154,154,154,
154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,154,155,155,155,155,155,155,155,155,155,
155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,156,156,156,156,156,156,156,156,156,156,156,156,156,
156,156,156,156,156,156,156,156,156,156,156,156,156,156,156,156,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,157,
157,157,157,157,157,157,157,157,157,157,157,157,157,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,
158,158,158,158,158,158,158,158,158,158,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,
159,159,159,159,159,159,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,
160,160,160,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,
162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,162,163,163,163,
163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,163,164,164,164,164,164,
164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,164,165,165,165,165,165,165,165,165,
165,165,165,165,165,165,165,165,165,165,165,165,165,165,165,165,165,165,165,165,165,166,166,166,166,166,166,166,166,166,166,166,
166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,166,167,167,167,167,167,167,167,167,167,167,167,167,167,167,
167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,167,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,168,
168,168,168,168,168,168,168,168,168,168,168,168,168,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,
169,169,169,169,169,169,169,169,169,169,169,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,
170,170,170,170,170,170,170,170,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,171,
171,171,171,171,171,171,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,172,
172,172,172,172,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,173,
173,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,174,175,
175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,175,176,176,176,
176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,176,177,177,177,177,177,
177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,178,178,178,178,178,178,178,
178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,179,179,179,179,179,179,179,179,179,
179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,179,180,180,180,180,180,180,180,180,180,180,180,
180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,180,181,181,181,181,181,181,181,181,181,181,181,181,181};

short             *x_int[2];
short             buffer[2*samp_per_frame];
config_t          config;
PFILE             mp3file;
int               mp3_hdl, file_hdl;
int               frames_processed;
long              wav_size;
uint32            enc_buffer[16384]; /* storage for 64 CodedData buffers */
int               enc_chunk = 0;     /* chunk (each 256Byte) counter     */

/* forward declarations */
void encodeSideInfo( side_info_t  si[2][2] );
void Huffmancodebits( enct8 *ix, int *xr, side_info_t *gi );
int  HuffmanCode(int table_select, enct8 *ix, int *xr);
int  HuffmanCount1(unsigned tbl, enct8 *ix, int *xr );
int  new_choose_table( enct8 ix[samp_per_frame2], unsigned int begin, unsigned int end );
void putbits(uint32 val, uint32 nbit);
int  count_bit(enct8 ix[samp_per_frame2], unsigned int start, unsigned int end, unsigned int table );
int  bigv_bitcount(enct8 ix[samp_per_frame2], side_info_t *gi);
void bigv_tab_select( enct8 ix[samp_per_frame2], side_info_t *cod_info );
void subdivide(side_info_t *cod_info);
void mdct_sub_int(int sb_sample[2][3][18][SBLIMIT], int (*mdct_freq)[2][samp_per_frame2]);
void filter_subband(short *buffer, int s[SBLIMIT], int k);
int  read_samples(short *sample_buffer, int frame_size);


bool checkString(int *file, char *string)
{
  char temp[4];

  rb->read(*file, temp, 4);

  return (*(long*)temp == *(long*)string) ? 1 : 0;
}

int Read16BitsLowHigh(PFILE fp)
{
	char first, second;

  rb->read(*fp, &first,  1);
  rb->read(*fp, &second, 1);

  return ((int)second << 8) | (first & 0xff);
}


int Read32BitsLowHigh(PFILE fp)
{
	int	first, second, result;

	first  = 0xffff & Read16BitsLowHigh(fp);
	second = 0xffff & Read16BitsLowHigh(fp);
	result = (second << 16) + first;

  return result;
}

void wave_close(void)
{
    rb->close(*config.wave.file);
}

PFILE fread_open(char *filename)
{
    file_hdl = rb->open(filename, O_RDONLY);
    return file_hdl < 0 ? NULL : &file_hdl;
}

int wave_open(void)
{
    unsigned short  wFormatTag;
    unsigned long   dAvgBytesPerSec;
    unsigned short  wBlockAlign;
    long            header_size;

    if((config.wave.file = fread_open(config.infile)) == NULL)
      return -1;

    if(!checkString(config.wave.file,"RIFF")) return -2;
    Read32BitsLowHigh(config.wave.file); /* complete wave chunk size */
    if(!checkString(config.wave.file,"WAVE")) return -3;
    if(!checkString(config.wave.file,"fmt ")) return -4;

    header_size = Read32BitsLowHigh(config.wave.file); /* chunk size */
    wFormatTag  = Read16BitsLowHigh(config.wave.file);

    config.wave.channels   = Read16BitsLowHigh(config.wave.file);
    config.wave.samplerate = Read32BitsLowHigh(config.wave.file);
    dAvgBytesPerSec        = Read32BitsLowHigh(config.wave.file);
    wBlockAlign            = Read16BitsLowHigh(config.wave.file);
    config.wave.bits       = Read16BitsLowHigh(config.wave.file);

    if(wFormatTag != 0x0001)                  return -5;
    if(config.wave.bits != 16)                return -6;
    if(config.wave.channels > 2)              return -7;
    if(!checkString(config.wave.file,"data")) return -8;

    header_size = 0x28;
    wav_size = rb->filesize(*config.wave.file);
    rb->lseek(*config.wave.file, header_size, SEEK_SET);

    config.wave.total_samples = (wav_size-header_size) / (2*config.wave.channels);
    config.wave.length        = config.wave.total_samples / config.wave.samplerate;

    return 0;
}

int read_samples(short *sample_buffer, int frame_size)
{
    int samples = rb->read(*config.wave.file, sample_buffer, sizeof(short) * frame_size) / sizeof(short);
    /* Pad last sample with zeros */
    if((samples < frame_size) && (samples > 0))
        while(samples < frame_size)
            sample_buffer[samples++] = 0;

    return samples;
}

inline uint32 myswap32(uint32 val)
{
  const uint8* src = (const uint8*)&val;

  return (uint32)src[3] | ((uint32)src[2] << 8) | ((uint32)src[1] << 16) | ((uint32)src[0] << 24);
}

void putbits(uint32 val, uint32 nbit)
{
  int new_bitpos = CodedData.bitpos + nbit;
  int i, ptrpos  = CodedData.bitpos >> 5;

  val = val & (0xffffffff >> (32 - nbit));

  /* data fit in one uint32 */
  if(((new_bitpos - 1) >> 5) == ptrpos)
    CodedData.bbuf[ptrpos] |= val << ((32 - new_bitpos) & 31);
  else
  {
    CodedData.bbuf[ptrpos  ] |= val >> ((new_bitpos - 32) & 31);
    CodedData.bbuf[ptrpos+1] |= val << ((32 - new_bitpos) & 31);
  }

  CodedData.bitpos = new_bitpos;

  /* copy iram mp3 buffer to sdram/file */
  if(new_bitpos >= 256 * 32)
  {
    if(config.byte_order != order_bigEndian)
      for(i=0; i<256; i++)
        CodedData.bbuf[i] = myswap32(CodedData.bbuf[i]);

    if(enc_chunk >= 64) /* sdram encoder buffer full? */
    {
      rb->write(*mp3file, enc_buffer, 16384*sizeof(uint32));
      enc_chunk = 0;
    }

    /* copy iram buffer to sdram */
    memcpy(enc_buffer + enc_chunk*256, CodedData.bbuf, 256*sizeof(uint32));
    enc_chunk++;

    CodedData.bbuf[0] = CodedData.bbuf[256];
    memset(CodedData.bbuf+1, 0, 256*sizeof(uint32));
    CodedData.bitpos &=31;
  }
}

/* open the device to write the bit stream into it */
void open_bitstream(char *bs_filenam) /* name of the bit stream file */
{
  mp3file = (mp3_hdl=rb->open(bs_filenam, O_WRONLY|O_CREAT|O_TRUNC)) < 0 ? NULL : &mp3_hdl;
}

/* This is called after a frame of audio has been quantized and coded.
   It will write the encoded audio to the bitstream. Note that from a
   layer3 encoder's perspective the bit stream is primarily a series
   of main_data() blocks, with header and side information inserted at
   the proper locations to maintain framing. See Figure A.7 in the IS */
void format_bitstream( enct8 enc[2][2][samp_per_frame2], side_info_t side[2][2], int (*xr)[2][samp_per_frame2] )
{
  int gr, ch;

  encodeSideInfo( side );

  for(gr=0; gr<2; gr++)
    for(ch=0; ch<config.wave.channels; ch++)
      Huffmancodebits( &enc[gr][ch][0], &xr[gr][ch][0], &side[gr][ch] );
}

void encodeSideInfo( side_info_t si[2][2] )
{
  int gr, ch, header;
  
  header  = 0xfff00000;
  header |= config.mpeg.type             << 19;
  header |= 1  /*config.mpeg.layr*/      << 17;
  header |= !config.mpeg.crc             << 16;
  header |= config.mpeg.bitrate_index    << 12;
  header |= config.mpeg.samplerate_index << 10;
  header |= config.mpeg.padding          <<  9;
  header |= config.mpeg.ext              <<  8;
  header |= config.mpeg.mode             <<  6;
  header |= config.mpeg.mode_ext         <<  4;
  header |= config.mpeg.copyright        <<  3;
  header |= config.mpeg.original         <<  2;
  header |= config.mpeg.emph             <<  0;

  putbits( header, 32 );
  putbits( 0, config.wave.channels == 2 ? 20 : 18 );

  for(gr=0; gr<2; gr++)
    for(ch=0; ch<config.wave.channels; ch++)
    {
      side_info_t *gi = &si[gr][ch];

      putbits( gi->part2_3_length,    12 );
      putbits( gi->big_values,         9 );
      putbits( gi->global_gain,        8 );
      putbits( gi->table_select[0],   10 );
      putbits( gi->table_select[1],    5 );
      putbits( gi->table_select[2],    5 );
      putbits( gi->region0_count,      4 );
      putbits( gi->region1_count,      3 );
      putbits( gi->table_select[3],    3 );
    }
}

/* Note the discussion of huffmancodebits() on pages 28 and 29 of the IS,
   as well as the definitions of the side information on pages 26 and 27. */
void Huffmancodebits( enct8 *ix, int *xr, side_info_t *gi )
{
  int region1Start;
  int region2Start;
  int i, bigvalues, count1End;
  int stuffingBits;
  int bitsWritten = 0;
  unsigned scalefac_index;

  /* 1: Write the bigvalues */
  bigvalues       = gi->big_values << 1;
  scalefac_index  = gi->region0_count + 1;
  region1Start    = scalefac_long[ scalefac_index ];
  scalefac_index += gi->region1_count + 1;
  region2Start    = scalefac_long[ scalefac_index ];

  for(i=0; i<region1Start; i+=2)
    bitsWritten += HuffmanCode(gi->table_select[0], ix+i, xr+i);

  for(   ; i<region2Start; i+=2)
    bitsWritten += HuffmanCode(gi->table_select[1], ix+i, xr+i);

  for(   ; i<bigvalues; i+=2)
    bitsWritten += HuffmanCode(gi->table_select[2], ix+i, xr+i);

  /* 2: Write count1 area */
  count1End = bigvalues + (gi->count1 << 2);
  for(i=bigvalues; i<count1End; i+=4)
    bitsWritten += HuffmanCount1(gi->table_select[3], ix+i, xr+i);

  if((stuffingBits = gi->part2_3_length - bitsWritten) != 0)
  {
    int stuffingWords = stuffingBits / 32;
    int remainingBits = stuffingBits % 32;

    if( remainingBits )
      putbits( ~0, remainingBits );

    /* Due to the nature of the Huffman code tables, we will pad with ones */
    while( stuffingWords-- )
      putbits( ~0, 32 );

    bitsWritten += stuffingBits;
  }
}

int HuffmanCount1(unsigned tbl, enct8 *ix, int *xr)
{
  uint32  dat, p, s;
  int     len, v, w, x, y;
  #define signv (xr[0] < 0 ? 1 : 0)
  #define signw (xr[1] < 0 ? 1 : 0)
  #define signx (xr[2] < 0 ? 1 : 0)
  #define signy (xr[3] < 0 ? 1 : 0)

  v = ix[0];
  w = ix[1];
  x = ix[2];
  y = ix[3];
  p = v + (w << 1) + (x << 2) + (y << 3);

  switch(p)
  {
    default: len = 0; s = 0; break;
    case  1: len = 1; s = signv; break;
    case  2: len = 1; s =                signw; break;
    case  3: len = 2; s = (signv << 1) + signw; break;
    case  4: len = 1; s =                               signx; break;
    case  5: len = 2; s = (signv << 1)                + signx; break;
    case  6: len = 2; s =                (signw << 1) + signx; break;
    case  7: len = 3; s = (signv << 2) + (signw << 1) + signx; break;
    case  8: len = 1; s =                                              signy; break;
    case  9: len = 2; s = (signv << 1)                               + signy; break;
    case 10: len = 2; s =                (signw << 1)                + signy; break;
    case 11: len = 3; s = (signv << 2) + (signw << 1)                + signy; break;
    case 12: len = 2; s =                               (signx << 1) + signy; break;
    case 13: len = 3; s = (signv << 2)                + (signx << 1) + signy; break;
    case 14: len = 3; s =                (signw << 2) + (signx << 1) + signy; break;
    case 15: len = 4; s = (signv << 3) + (signw << 2) + (signx << 1) + signy; break;
  }

  dat = (ht_count1[tbl][0][p] << len) + s;
  len =  ht_count1[tbl][1][p];
  putbits( dat, len );

  return len;
}

/* Implements the pseudocode of page 98 of the IS */
int HuffmanCode(int table_select, enct8 *ix, int *xr)
{
  unsigned     linbitsx, linbitsy, linbits, idx;
  const struct huffcodetab *h;
  int          x, y, bit;
  uint32       code;
  #define sign_x (xr[0] < 0 ? 1 : 0)
  #define sign_y (xr[1] < 0 ? 1 : 0)

  if(table_select == 0)
    return 0;

  x        = ix[0];
  y        = ix[1];
  h        = &ht[table_select];
  linbits  = h->linbits;
  linbitsx = linbitsy = 0;

  if( table_select > 15 )
  { /* ESC-table is used */
    if(x > 14)  { linbitsx = x - 15;  x = 15; }
    if(y > 14)  { linbitsy = y - 15;  y = 15; }

    idx  = (x * h->ylen) + y;
    code = h->table[idx];
    bit  = h->hlen [idx];

    if(x)
    {
      if(x > 14)
      {
        code = (code << linbits) | linbitsx;
        bit += linbits;
      }

      code = (code << 1) | sign_x;
      bit += 1;
    }

    if(y)
    {
      if(y > 14)
      {
        code = (code << linbits) | linbitsy;
        bit += linbits;
      }

      code = (code << 1) | sign_y;
      bit += 1;
    }
  }
  else
  { /* No ESC-words */
    idx  = (x * h->ylen) + y;
    code = h->table[idx];
    bit  = h->hlen [idx];

    if(x)
    {
      code = (code << 1) | sign_x;
      bit += 1;
    }

    if(y)
    {
      code = (code << 1) | sign_y;
      bit += 1;
    }
  }

  putbits( code, bit );
  
  return bit;
}

/*************************************************************************/
/*  Choose the Huffman table that will encode ix[begin..end] with             */
/*  the fewest bits.                                                          */
/*  Note: This code contains knowledge about the sizes and characteristics    */
/*  of the Huffman tables as defined in the IS (Table B.7), and will not work */
/*  with any arbitrary tables.                                                */
/*************************************************************************/
int new_choose_table( enct8 ix[samp_per_frame2], uint32 begin, uint32 end )
{
  uint32 i;
  int    max, sum0, sum1, table0, table1;
  
  for(i=begin,max=0; i<end; i++)
    if(ix[i] > max)
      max = ix[i];

  if(!max)
    return 0;
  
  table0 = 0;
  table1 = 0;
  
  if(max <= 15)
  {
    /* try tables with no linbits */
    /* indx: 0  1  2  3  4  5  6  7  8  9 10 11 12  13 14  15 */
    /* xlen: 0, 2, 3, 3, 0, 4, 4, 6, 6, 6, 8, 8, 8, 16, 0, 16 */
    for(table0=0; table0<14; table0++)
      if(ht[table0].xlen > max)
        break;

    sum0 = count_bit(ix, begin, end, table0);
      
    switch( table0 )
    {
      case  2: sum1 = count_bit( ix, begin, end, 3 );
               if(sum1 <= sum0) table0 = 3;  break;

      case  5: sum1 = count_bit( ix, begin, end, 6 );
               if(sum1 <= sum0) table0 = 6;  break;

      case  7: sum1 = count_bit( ix, begin, end, 8 );
               if(sum1 <= sum0)  { table0 = 8; sum0 = sum1; }
               sum1 = count_bit( ix, begin, end, 9 );
               if(sum1 <= sum0) table0 = 9;  break;
        
      case 10: sum1 = count_bit( ix, begin, end, 11 );
               if(sum1 <= sum0)  { table0 =11; sum0 = sum1; }
               sum1 = count_bit( ix, begin, end, 12);
               if(sum1 <= sum0) table0 = 12; break;
        
      case 13: sum1 = count_bit( ix, begin, end, 15 );
               if(sum1 <= sum0) table0 = 15; break;
    }
  }
  else
  {
    /* try tables with linbits */
    max -= 15;

    /* index : 15   16   17   18   19   20   21   22  23  */
    /* linmax:  0    1    3    7   15   63  255 1023 8191 */
    for(table0=15; table0<24; table0++)
      if(ht[table0].linmax >= max)
        break;

    /* index : 24   25   26   27   28   29   30   31 */
    /* linmax: 15   31   63  127  255  511 2047 8191 */
    for(table1=24; table1<32; table1++)
      if(ht[table1].linmax >= max)
        break;

    sum0 = count_bit(ix, begin, end, table0);
    sum1 = count_bit(ix, begin, end, table1);

    if(sum1 < sum0)
      table0 = table1;
  }
  return table0;
}

/*************************************************************************/
/* Function: Count the number of bits necessary to code the subregion.   */
/*************************************************************************/
int count_bit(enct8 ix[samp_per_frame2], unsigned int start, unsigned int end, unsigned int table )
{
  uint32       i;
  int          sum;
  int          x, y;
  unsigned     linbits, ylen;
  const struct huffcodetab *h;

  h    = &ht[table];
  sum  = 0;
  ylen = h->ylen;

  if(table > 15)
  { // ESC-table is used 
    linbits = h->linbits;
    for(i=start; i<end; i+=2)
    {
      x = ix[i];
      y = ix[i+1];

      if(x)
      {
        if(x > 14) { x = 15; sum += linbits; }
        sum++;
      }

      if(y)
      {
        if(y > 14) { y = 15; sum += linbits; }
        sum++;
      }
  
      sum += h->hlen[(x * ylen) + y];
    }
  }
  else
  { /* No ESC-words */
    for(i=start; i<end; i+=2)
    {
      x = ix[i];
      y = ix[i+1];

      sum += h->hlen[(x * ylen) + y];

      if(x) sum++;
      if(y) sum++;
    }
  }
  
  return sum;
}

/*************************************************************************/
/*   Function: Quantization of the vector xr ( -> ix)                    */
/*************************************************************************/
int quantize_int(int xr[samp_per_frame2], enct8 ix[samp_per_frame2], side_info_t *cod_info)
{
  int    i;
#if 0
  long   step;
  uint32 frac_pow[] = { 0, 12400, 27146, 44682 };

  step  = 1 << cod_info->quantizerStepSize / 4;
  step += (step * frac_pow[cod_info->quantizerStepSize & 3] + 32768) >> 16;

  for(i=samp_per_frame2; i--; )
    ix[i] = int2idx[4 * abs(xr[i]) / step];

  return 1;
#else
  uint32 max=0, val, step, frac_pow[] = { 0x40000, 0x35d14, 0x2d414,0x260e0 };

  step = frac_pow[cod_info->quantizerStepSize & 3] >> cod_info->quantizerStepSize / 4;

  for(i=samp_per_frame2; i--; )
  {
    val   = (((unsigned long)abs(xr[i]) * step + 32768) >> 16);
    max  |= val;
    ix[i] = int2idx[val];
  }
  return max < 4096 ? 1 : 0;
#endif
}

/*************************************************************************/
/* Function: Calculation of rzero, count1, big_values                    */
/* (Partitions ix into big values, quadruples and zeros).                */
/*************************************************************************/
int calc_runlen( enct8 ix[samp_per_frame2], side_info_t *cod_info )
{
  int  p, i, sum0 = 0, sum1 = 0;

  for(i=samp_per_frame2; i-=2; )
    if(ix[i-1] | ix[i-2])
      break;

  cod_info->count1 = 0;

  for( ; i>3; i-=4)
  {
    int v = ix[i-1];
    int w = ix[i-2];
    int x = ix[i-3];
    int y = ix[i-4];
    
    if((v | w | x | y) <= 1)
    {
      p = (y) + (x<<1) + (w<<2) + (v<<3);

      sum0 += ht_count1[0][1][p]; /* add table0 hlength */
      sum1 += ht_count1[1][1][p]; /* add table1 hlength */

      cod_info->count1++;
    }
    else break;
  }

  cod_info->big_values = i >> 1;

  if(sum0 < sum1)
  {
    cod_info->table_select[3] = 0;
    return sum0;
  }
  else
  {
    cod_info->table_select[3] = 1;
    return sum1;
  }
}

/*************************************************************************/
/* presumable subdivides the bigvalue region which will use separate Huffman tables */
/*************************************************************************/
void subdivide(side_info_t *cod_info)
{
  int scfb_anz = 0;
  int bigvalues_region;
  int thiscount, index;
  
  if( !cod_info->big_values )
  { /* no big_values region */
    cod_info->region0_count = 0;
    cod_info->region1_count = 0;
  }
  else
  {
    bigvalues_region = 2 * cod_info->big_values;
    
    /* Calculate scfb_anz */
    while( scalefac_long[scfb_anz] < bigvalues_region )
      scfb_anz++;
      
    cod_info->region0_count = subdv_table[scfb_anz].region0_count;
    thiscount = cod_info->region0_count;
    index = thiscount + 1;
    while(thiscount && (scalefac_long[index] > bigvalues_region))
    {
      thiscount--;
      index--;
    }
    cod_info->region0_count = thiscount;
    cod_info->region1_count = subdv_table[scfb_anz].region1_count;
    index = cod_info->region0_count + cod_info->region1_count + 2;
    thiscount = cod_info->region1_count;
    while(thiscount && (scalefac_long[index] > bigvalues_region))
    {
      thiscount--;
      index--;
    }
    cod_info->region1_count = thiscount;
    cod_info->address1 = scalefac_long[cod_info->region0_count+1];
    cod_info->address2 = scalefac_long[cod_info->region0_count+cod_info->region1_count+2];
    cod_info->address3 = bigvalues_region;
  }
}

/*************************************************************************/
/*   Function: Select huffman code tables for bigvalues regions */
/*************************************************************************/
void bigv_tab_select( enct8 ix[samp_per_frame2], side_info_t *cod_info )
{
  cod_info->table_select[0] = 0;
  cod_info->table_select[1] = 0;
  cod_info->table_select[2] = 0;
  
  if( cod_info->address1 > 0 )
    cod_info->table_select[0] = new_choose_table(ix,         0         , cod_info->address1);
    
  if( cod_info->address2 > cod_info->address1 )
    cod_info->table_select[1] = new_choose_table(ix, cod_info->address1, cod_info->address2);
    
  if( cod_info->big_values<<1 > cod_info->address2 )
    cod_info->table_select[2] = new_choose_table(ix, cod_info->address2, cod_info->big_values<<1);
}

/*************************************************************************/
/* Function: Count the number of bits necessary to code the bigvalues region */
/*************************************************************************/
int bigv_bitcount(enct8 ix[samp_per_frame2], side_info_t *gi)
{
  int bits = 0;
  uint32 table;

  if((table=gi->table_select[0]))  /* region0 */
    bits += count_bit(ix,     0       , gi->address1, table);

  if((table=gi->table_select[1]))  /* region1 */
    bits += count_bit(ix, gi->address1, gi->address2, table);

  if((table=gi->table_select[2]))  /* region2 */
    bits += count_bit(ix, gi->address2, gi->address3, table);

  return bits;
}

int quantcnt;

/* Speed up the outer_loop code which is called by iteration_loop.
   The outer_loop function precedes the call to the function inner_loop
   with a call to bin_search gain defined below,
   which returns a good starting quantizerStepSize. */
int quantize_and_count_bits(int xr[samp_per_frame2], enct8 ix[samp_per_frame2], side_info_t *cod_info)
{
  int bits = 10000;

  quantcnt++;

  if(quantize_int(xr, ix, cod_info))
  {
    bits = calc_runlen(ix, cod_info);		 /* rzero,count1,big_values*/
    subdivide(cod_info);		             /* bigvalues sfb division */
    bigv_tab_select(ix,cod_info);        /* codebook selection*/
    bits += bigv_bitcount(ix,cod_info);	 /* bit count */
  }

  return bits;
}

/******************************************************************************/
/* The code selects the best quantizerStepSize for a particular set of scalefacs                                                            */
/******************************************************************************/ 
int inner_loop_int(int xr[2][2][samp_per_frame2], int max_bits, side_info_t *cod_info, int gr, int ch )
{
  int   *xrs;  /* int[samp_per_frame2] *xr; */
  enct8 *ix;   /* int[samp_per_frame2] *ix; */
  int   bits;

  xrs = &xr[gr][ch][0];
  ix  = enc_data[gr][ch];

  while((bits=quantize_and_count_bits(xrs, ix, cod_info)) < max_bits- 128)
  {
    if(cod_info->quantizerStepSize == 0)
      break;

    if(cod_info->quantizerStepSize <= 2)
      cod_info->quantizerStepSize = 0;
    else
      cod_info->quantizerStepSize -= 2;
  }

  while(bits > max_bits)
  {
    cod_info->quantizerStepSize++;
    bits = quantize_and_count_bits(xrs, ix, cod_info);
  }

  return bits;
}

/************************************************************************/
/*  iteration_loop()                                                    */
/************************************************************************/
void iteration_loop(int mdct_freq_org[2][2][samp_per_frame2], side_info_t cod_info[2][2], int mean_bits)
{
  int     max_bits;
  int     ch, gr;
  int     ResvSize = 0; /* Layer3 bit reservoir: Described in C.1.5.4.2.2 of the IS */
  
  for(gr=2; gr--; )
  {
    for(ch=config.wave.channels; ch--; )
    {
      /* calculation of number of available bit( per granule ) */
      max_bits = mean_bits / config.wave.channels;

      cod_info[gr][ch].big_values        = 0;
      cod_info[gr][ch].count1            = 0;
      cod_info[gr][ch].table_select[0]   = 0;
      cod_info[gr][ch].table_select[1]   = 0;
      cod_info[gr][ch].table_select[2]   = 0;
      cod_info[gr][ch].region0_count     = 0;
      cod_info[gr][ch].region1_count     = 0;
      cod_info[gr][ch].table_select[3]   = 0;
      cod_info[gr][ch].part2_3_length    = inner_loop_int(mdct_freq_org, max_bits, &cod_info[gr][ch], gr, ch);
      cod_info[gr][ch].global_gain       = cod_info[gr][ch].quantizerStepSize + 210 - 0x3c;

      /* Readjusts the size of the reservoir to reflect the granule's usage */
      ResvSize += max_bits - cod_info[gr][ch].part2_3_length;
    }
  }
  
/* Makes sure that the reservoir size is within limits, possibly by adding stuffing
   bits. Note that stuffing bits are added by increasing a granule's part2_3_length */
  cod_info[0][0].part2_3_length += ResvSize;
}

/*-------------------------------------------------------------------*/
/*   Function: Calculation of the MDCT                               */
/*   In the case of long blocks ( block_type 0,1,3 ) there are       */
/*   36 coefficents in the time domain and 18 in the frequency       */
/*   domain.                                                         */
/*-------------------------------------------------------------------*/

/* TODO: This MDCT implementation is very crude, and should be replaced by
   a completely different algorithm. */
void mdct_int( int *in, int *out )
{
  int m, tmp=0;
  
  for(m=18; m--; )
  {
#ifdef CPU_COLDFIRE
    { int *wint  = win_int[m];
      int *indat = in;

      asm volatile(
      "movem.l (%[indat]), %%d0-%%d7\n"
      "move.l (%[wint])+, %%a5\n"
      "mac.l %%d0, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d1, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d2, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d3, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d4, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d5, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d6, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d7, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "movem.l (32,%[indat]), %%d0-%%d7\n"
      "mac.l %%d0, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d1, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d2, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d3, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d4, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d5, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d6, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d7, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "movem.l (64,%[indat]), %%d0-%%d7\n"
      "mac.l %%d0, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d1, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d2, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d3, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d4, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d5, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d6, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d7, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "movem.l (96,%[indat]), %%d0-%%d7\n"
      "mac.l %%d0, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d1, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d2, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d3, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d4, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d5, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d6, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d7, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "movem.l (128,%[indat]), %%d0-%%d3\n"
      "mac.l %%d0, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d1, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d2, %%a5, (%[wint])+, %%a5, %%acc0\n"
      "mac.l %%d3, %%a5, %%acc0\n"
      "movclr.l %%acc0, %[tmp]"
        : [wint] "+a" (wint), [tmp] "+r" (tmp) : [indat] "a" (indat)
        : "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "a5");
    }
#else
    int k;
    for(k=36,tmp=0; k--; )
      tmp += in[k] * win_int[m][k];
#endif
    out[m] = (tmp + 16384) >> 15;
  }
}


void mdct_sub_int(int sb_sample[2][3][18][SBLIMIT], int (*mdct_freq)[2][samp_per_frame2])
{
  int (*mdct_enc)[2][32][18] = (int (*)[2][32][18]) mdct_freq;
  int ch, gr, band, k, bu, bd;
  
  for(gr=0; gr<2; gr++)
    for(ch=config.wave.channels; ch--; )
    {
      /* 576=4*16*9: Compensate for inversion in the analysis filter */
      for(band=33; (band-=2)>0; )
        for(k=19; (k-=2)>0; )
          sb_sample[ch][gr+1][k][band] = -sb_sample[ch][gr+1][k][band];

      /* 82944=4*32*648: Perform imdct of 18 previous subband samples + 18 current subband samples */
      for(band=32; band--; )
      {
        for(k=18; k--; )
        {
          mdct_in[k]    = sb_sample[ch][ gr ][k][band];
          mdct_in[k+18] = sb_sample[ch][gr+1][k][band];
        }

        mdct_int(mdct_in, &mdct_enc[gr][ch][band][0]);
      }

      /* 1024=4*256: Perform aliasing reduction butterfly*/
      for(band=31; band--; )
        for(k=8; k--; )
        {
          bu = mdct_enc[gr][ch][band][17-k] * cs_int[k] + mdct_enc[gr][ch][band+1][k]  * ca_int[k];
          bd = mdct_enc[gr][ch][band+1][k]  * cs_int[k] - mdct_enc[gr][ch][band][17-k] * ca_int[k];
          mdct_enc[gr][ch][band][17-k] = (bu + 16384) >> 15;
          mdct_enc[gr][ch][band+1][k]  = (bd + 16384) >> 15;
        }
    }

  /* Save latest granule's subband samples to be used in the next mdct call */
  for(ch=config.wave.channels ;ch--; )
    memcpy(sb_sample[ch][0], sb_sample[ch][2], 18 * 32 * sizeof(int));
}

void filter_subband(short *buffer, int s[SBLIMIT], int k)
{
  short *enwindow = enwindow_int;
  int   i, j, tmp = 0;
#ifdef CPU_COLDFIRE 
  int   reg_buff[14]; /* register storage buffer */
#endif

  /* replace 32 oldest samples with 32 new samples */
  /* 2304=72*32: PCM Samples are little-endian, swap if necessary */
  if(config.byte_order == order_bigEndian)
  {
    for(i=32; i--; )
    {
      j = *(unsigned short*)(buffer+=2);
      x_int[k][i+off[k]] = (short)((j >> 8) | (j << 8));
    }
  }
  else
  {
    for(i=32; i--; )
      x_int[k][i+off[k]] = (short)*(buffer+=2);
  }

  /* 36864=72*512: shift samples into proper window positions */
#ifdef CPU_COLDFIRE
  { short *xint = &x_int[k][off[k]];
    short *yint = y_int;

    asm volatile ("movem.l %%d0/%%d2-%%d7/%%a2-%%a7,(%0)\n" : : "a" (reg_buff) : "d0");
    asm volatile(
    "moveq.l #32, %%d0\n"
    "move.l %%d0, %%acc2\n"               /* set loop counter */
    "move.l %[xint], %%d0\n"              /* d0 = x_int[k]   */
    "or.l #0x3ff, %%d0\n"
    "move.l %%d0, %%mask\n"               /* set address mask */
    "move.l (%[xint]), %%d4\n"            /* d4 =  x_int[k][off[k]] */

  "loop_start:\n"
    "movem.l (%[enwindow]), %%d0-%%d3\n"  /* load 4 values */
    "mac.w %%d0u, %%d4u, (0x080,%[xint])&, %%d5, %%acc0\n"
    "mac.w %%d0l, %%d5u, (0x100,%[xint])&, %%d6, %%acc0\n"
    "mac.w %%d1u, %%d6u, (0x180,%[xint])&, %%d7, %%acc0\n"
    "mac.w %%d1l, %%d7u, (0x200,%[xint])&, %%a2, %%acc0\n"
    "mac.w %%d2u, %%a2u, (0x280,%[xint])&, %%a3, %%acc0\n"
    "mac.w %%d2l, %%a3u, (0x300,%[xint])&, %%a4, %%acc0\n"
    "mac.w %%d3u, %%a4u, (0x380,%[xint])&, %%a5, %%acc0\n"
    "mac.w %%d3l, %%a5u,                         %%acc0\n"

    "movem.l (16,%[enwindow]), %%d0-%%d3\n" /* load 8 values */
    "mac.w %%d0u, %%d4l, %%acc1\n"
    "mac.w %%d0l, %%d5l, %%acc1\n"
    "mac.w %%d1u, %%d6l, %%acc1\n"
    "mac.w %%d1l, %%d7l, %%acc1\n"
    "mac.w %%d2u, %%a2l, %%acc1\n"
    "mac.w %%d2l, %%a3l, %%acc1\n"
    "mac.w %%d3u, %%a4l, %%acc1\n"
    "addq.l #4, %[xint]\n"                  /* xint += 2 */
    "mac.w %%d3l, %%a5l, (%[xint])&, %%d4, %%acc1\n"

    "movclr.l %%acc0, %%d5\n"
    "movclr.l %%acc1, %%d6\n"
    "move.l #262144, %%d7\n"
    "add.l %%d7, %%d5\n"
    "add.l %%d7, %%d6\n"
    "moveq.l #19, %%d7\n"
    "asr.l %%d7, %%d5\n"
    "asr.l %%d7, %%d6\n"
    "move.w %%d5, (%[yint])+\n"
    "move.w %%d6, (%[yint])+\n"

    "add.l #32, %[enwindow]\n"              /* enwindow += 16 */

    "moveq.l #1, %%d0\n"
    "msac.l %%d0, %%d0, %%acc2\n"
    "move.l %%acc2, %%d0\n"
    "tst.b %%d0\n"
    "jbne loop_start\n"

    : [xint] "+a" (xint), [yint] "+a" (yint)
    : [enwindow] "a" (enwindow)
    : "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "a2", "a3", "a4", "a5");

    asm volatile ("movem.l (%0),%%d0/%%d2-%%d7/%%a2-%%a7\n" : : "a" (reg_buff) : "d0");
  }
#else
  for(i=0; i<64; i++)
  {
    for(j=0, tmp=0; j<512; j+=64)
      tmp += (int)x_int[k][(i+0+j+off[k])&(HAN_SIZE-1)] * (int)*(enwindow++);
    y_int[i] = (short)((tmp + (1<<18)) >> 19);
  }
#endif
    
  /* 147456=72*2048 */
  for(i=SBLIMIT; i--; ) // SBLIMIT: 32
  {
    short *filt = filter_int[i];

#ifdef CPU_COLDFIRE
    {
      asm volatile(
      "move.l (%[yint])+, %%a5\n"
      "movem.l (%[filt]), %%d0-%%d7\n"
      "mac.w %%d0u, %%a5u,                       %%acc0\n"
      "mac.w %%d0l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d1u, %%a5u,                       %%acc0\n"
      "mac.w %%d1l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d2u, %%a5u,                       %%acc0\n"
      "mac.w %%d2l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d3u, %%a5u,                       %%acc0\n"
      "mac.w %%d3l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d4u, %%a5u,                       %%acc0\n"
      "mac.w %%d4l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d5u, %%a5u,                       %%acc0\n"
      "mac.w %%d5l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d6u, %%a5u,                       %%acc0\n"
      "mac.w %%d6l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d7u, %%a5u,                       %%acc0\n"
      "mac.w %%d7l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "movem.l (32,%[filt]), %%d0-%%d7\n"
      "mac.w %%d0u, %%a5u,                       %%acc0\n"
      "mac.w %%d0l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d1u, %%a5u,                       %%acc0\n"
      "mac.w %%d1l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d2u, %%a5u,                       %%acc0\n"
      "mac.w %%d2l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d3u, %%a5u,                       %%acc0\n"
      "mac.w %%d3l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d4u, %%a5u,                       %%acc0\n"
      "mac.w %%d4l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d5u, %%a5u,                       %%acc0\n"
      "mac.w %%d5l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d6u, %%a5u,                       %%acc0\n"
      "mac.w %%d6l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d7u, %%a5u,                       %%acc0\n"
      "mac.w %%d7l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "movem.l (64,%[filt]), %%d0-%%d7\n"
      "mac.w %%d0u, %%a5u,                       %%acc0\n"
      "mac.w %%d0l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d1u, %%a5u,                       %%acc0\n"
      "mac.w %%d1l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d2u, %%a5u,                       %%acc0\n"
      "mac.w %%d2l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d3u, %%a5u,                       %%acc0\n"
      "mac.w %%d3l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d4u, %%a5u,                       %%acc0\n"
      "mac.w %%d4l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d5u, %%a5u,                       %%acc0\n"
      "mac.w %%d5l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d6u, %%a5u,                       %%acc0\n"
      "mac.w %%d6l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d7u, %%a5u,                       %%acc0\n"
      "mac.w %%d7l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "movem.l (96,%[filt]), %%d0-%%d7\n"
      "mac.w %%d0u, %%a5u,                       %%acc0\n"
      "mac.w %%d0l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d1u, %%a5u,                       %%acc0\n"
      "mac.w %%d1l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d2u, %%a5u,                       %%acc0\n"
      "mac.w %%d2l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d3u, %%a5u,                       %%acc0\n"
      "mac.w %%d3l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d4u, %%a5u,                       %%acc0\n"
      "mac.w %%d4l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d5u, %%a5u,                       %%acc0\n"
      "mac.w %%d5l, %%a5l, (%[yint])+, %%a5, %%acc0\n"
      "mac.w %%d6u, %%a5u,                       %%acc0\n"
      "mac.w %%d6l, %%a5l, (%[yint]), %%a5, %%acc0\n"
      "mac.w %%d7u, %%a5u,                       %%acc0\n"
      "mac.w %%d7l, %%a5l,                       %%acc0\n"
      "lea.l (-31*4, %[yint]), %[yint]\n" /* wrap yint back to start */
      "movclr.l %%acc0, %[tmp]"
      : [tmp] "=r" (tmp) : [filt] "a" (filt), [yint] "a" (y_int)
      : "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "a5" );
    }
#else
    for(j=64, tmp=0; j--; )
      tmp += (long)filt[j] * (long)y_int[j];
#endif
    s[i] = (tmp + 16384) >> 15;
  }

  off[k] = (off[k] + 480) & (HAN_SIZE-1); /* offset is modulo HAN_SIZE */
}

void compress(void)
{
  int             channel;
  int             i;
  char            stg[20];
  int             gr;
  side_info_t     cod_info[2][2];
  short           *buffer_window[2];
  unsigned long   avg_slots_per_frame;
  long            frac_slots_per_frame;
  long            whole_slots_per_frame;
  long            slot_lag;
  int             mean_bits;
  int             sideinfo_len;

  open_bitstream(config.outfile);

  memset(cod_info    , 0                 , sizeof(cod_info    ));
  memset(x_int0      , 0                 , sizeof(x_int0      ));
  memset(x_int1      , 0                 , sizeof(x_int1      ));
  memset(y_int       , 0                 , sizeof(y_int       ));
  memset(mdct_freq   , 0                 , sizeof(mdct_freq   ));
  memset(enc_data    , 0                 , sizeof(enc_data    ));
  memset(off         , 0                 , sizeof(off         ));
  memset(mdct_in     , 0                 , sizeof(mdct_in     ));
  memset(sb_sample   , 0                 , sizeof(sb_sample   ));
  memset(&CodedData  , 0                 , sizeof(CodedData   ));
  memcpy(scalefac_long, sfBandIndex[config.mpeg.samplerate_index + (config.mpeg.type * 3)], sizeof(scalefac_long));
  memcpy(ca_int      , ca_int_const      , sizeof(ca_int      ));
  memcpy(cs_int      , cs_int_const      , sizeof(cs_int      ));
  memcpy(win_int     , win_int_const     , sizeof(win_int     ));
  memcpy(filter_int  , filter_int_const  , sizeof(filter_int  ));
  memcpy(enwindow_int, enwindow_int_const, sizeof(enwindow_int));
  memcpy(int2idx     , int2idx_const     , sizeof(int2idx     ));
  memcpy(ht_count1   , ht_count1_const   , sizeof(ht_count1   ));
  memcpy( t1HB       , t1HB_const        , sizeof(t1HB        ));
  memcpy( t2HB       , t2HB_const        , sizeof(t2HB        ));
  memcpy( t3HB       , t3HB_const        , sizeof(t3HB        ));
  memcpy( t5HB       , t5HB_const        , sizeof(t5HB        ));
  memcpy( t6HB       , t6HB_const        , sizeof(t6HB        ));
  memcpy( t7HB       , t7HB_const        , sizeof(t7HB        ));
  memcpy( t8HB       , t8HB_const        , sizeof(t8HB        ));
  memcpy( t9HB       , t9HB_const        , sizeof(t9HB        ));
  memcpy(t10HB       , t10HB_const       , sizeof(t10HB       ));
  memcpy(t11HB       , t11HB_const       , sizeof(t11HB       ));
  memcpy(t12HB       , t12HB_const       , sizeof(t12HB       ));
  memcpy(t13HB       , t13HB_const       , sizeof(t13HB       ));
  memcpy(t15HB       , t15HB_const       , sizeof(t15HB       ));
  memcpy(t16HB       , t16HB_const       , sizeof(t16HB       ));
  memcpy(t24HB       , t24HB_const       , sizeof(t24HB       ));
  memcpy( t1l        , t1l_const         , sizeof(t1l         ));
  memcpy( t2l        , t2l_const         , sizeof(t2l         ));
  memcpy( t3l        , t3l_const         , sizeof(t3l         ));
  memcpy( t5l        , t5l_const         , sizeof(t5l         ));
  memcpy( t6l        , t6l_const         , sizeof(t6l         ));
  memcpy( t7l        , t7l_const         , sizeof(t7l         ));
  memcpy( t8l        , t8l_const         , sizeof(t8l         ));
  memcpy( t9l        , t9l_const         , sizeof(t9l         ));
  memcpy(t10l        , t10l_const        , sizeof(t10l        ));
  memcpy(t11l        , t11l_const        , sizeof(t11l        ));
  memcpy(t12l        , t12l_const        , sizeof(t12l        ));
  memcpy(t13l        , t13l_const        , sizeof(t13l        ));
  memcpy(t15l        , t15l_const        , sizeof(t15l        ));
  memcpy(t16l        , t16l_const        , sizeof(t16l        ));
  memcpy(t24l        , t24l_const        , sizeof(t24l        ));
  memcpy(ht          , ht_const          , sizeof(ht          ));

  /* I don't know, wether this is really necessary */
  ht[ 0].table =  NULL;  ht[ 0].hlen = NULL;// Apparently not used
  ht[ 1].table =  t1HB;  ht[ 1].hlen =  t1l;
  ht[ 2].table =  t2HB;  ht[ 2].hlen =  t2l;
  ht[ 3].table =  t3HB;  ht[ 3].hlen =  t3l;
  ht[ 4].table =  NULL;  ht[ 4].hlen = NULL;// Apparently not used
  ht[ 5].table =  t5HB;  ht[ 5].hlen =  t5l;
  ht[ 6].table =  t6HB;  ht[ 6].hlen =  t6l;
  ht[ 7].table =  t7HB;  ht[ 7].hlen =  t7l;
  ht[ 8].table =  t8HB;  ht[ 8].hlen =  t8l;
  ht[ 9].table =  t9HB;  ht[ 9].hlen =  t9l;
  ht[10].table = t10HB;  ht[10].hlen = t10l;
  ht[11].table = t11HB;  ht[11].hlen = t11l;
  ht[12].table = t12HB;  ht[12].hlen = t12l;
  ht[13].table = t13HB;  ht[13].hlen = t13l;
  ht[14].table =  NULL;  ht[14].hlen = NULL;// Apparently not used
  ht[15].table = t15HB;  ht[15].hlen = t15l;
  ht[16].table = t16HB;  ht[16].hlen = t16l;
  ht[17].table = t16HB;  ht[17].hlen = t16l;
  ht[18].table = t16HB;  ht[18].hlen = t16l;
  ht[19].table = t16HB;  ht[19].hlen = t16l;
  ht[20].table = t16HB;  ht[20].hlen = t16l;
  ht[21].table = t16HB;  ht[21].hlen = t16l;
  ht[22].table = t16HB;  ht[22].hlen = t16l;
  ht[23].table = t16HB;  ht[23].hlen = t16l;
  ht[24].table = t24HB;  ht[24].hlen = t24l;
  ht[25].table = t24HB;  ht[25].hlen = t24l;
  ht[26].table = t24HB;  ht[26].hlen = t24l;
  ht[27].table = t24HB;  ht[27].hlen = t24l;
  ht[28].table = t24HB;  ht[28].hlen = t24l;
  ht[29].table = t24HB;  ht[29].hlen = t24l;
  ht[30].table = t24HB;  ht[30].hlen = t24l;
  ht[31].table = t24HB;  ht[31].hlen = t24l;

  x_int[0] = x_int0;
  x_int[1] = x_int1;

#ifdef CPU_COLDFIRE
  asm volatile ("move.l #0, %macsr"); /* integer mode */
#endif
  
#ifndef SIMULATOR
  if(((long)x_int0 | (long)x_int1) & 0x7ff)
    return; /* both arrays must be aligned to 0x800 boundary */
#endif

  if(config.wave.channels == 1)
    sideinfo_len = 32 + 136;
  else
    sideinfo_len = 32 + 256;

  /* Set initial step size */
  cod_info[0][0].quantizerStepSize = 0x10;
  cod_info[0][1].quantizerStepSize = 0x10;
  cod_info[1][0].quantizerStepSize = 0x10;
  cod_info[1][1].quantizerStepSize = 0x10;

  /* Figure average number of 'slots' per frame. */
  frames_processed      = 0;
  avg_slots_per_frame   = (uint32)(samp_per_frame * 8000 * config.mpeg.bitr) / config.wave.samplerate;
  whole_slots_per_frame = avg_slots_per_frame / 64;
  frac_slots_per_frame  = avg_slots_per_frame - 64 * whole_slots_per_frame;
  slot_lag              = -frac_slots_per_frame;
  if(frac_slots_per_frame == 0)
		config.mpeg.padding = 0;

  while(1)
  {
    rb->lcd_clear_display();
    rb->snprintf(stg, 20, "Frame %d / %d", frames_processed++, wav_size/samp_per_frame/4);
    rb->lcd_putsxy(4, 20, stg);
    rb->lcd_update();

    if(read_samples(buffer, samp_per_frame<<1) == 0)
      break;

    buffer_window[0] = &buffer[-2];
    buffer_window[1] = &buffer[-1];

    if(frac_slots_per_frame)
    {
      if(slot_lag > frac_slots_per_frame - 64)
      { /* No padding for this frame */
        slot_lag -= frac_slots_per_frame;
        config.mpeg.padding = 0;
      }
      else 
      { /* Padding for this frame */
        slot_lag += (64 - frac_slots_per_frame);
        config.mpeg.padding = 1;
      }
    }

    config.mpeg.bits_per_frame = 8 * (whole_slots_per_frame + config.mpeg.padding);
    mean_bits = (config.mpeg.bits_per_frame - sideinfo_len) >> 1;

    /* polyphase filtering */
    for(gr=0; gr<2; gr++)
      for(channel=config.wave.channels; channel--; )
        for(i=0; i<18; i++)
        {
          filter_subband(buffer_window[channel], &sb_sample[channel][gr+1][i][0], channel);
          buffer_window[channel] += 64;
        }

    mdct_sub_int(sb_sample, mdct_freq);
    /* bit and noise allocation */
    iteration_loop(mdct_freq, cod_info, mean_bits);
    /* write the frame to the bitstream */
    format_bitstream(enc_data, cod_info, mdct_freq);
  }
  /* write last chunks to disk */
  rb->write(*mp3file, enc_buffer, enc_chunk*256*sizeof(uint32));
}

static int find_bitrate_index(int bitr)
{
    static long mpeg1[15] = {0,32,40,48,56,64,80,96,112,128,160,192,224,256,320};
    int i;

    for(i=0;i<15;i++)
        if(bitr==mpeg1[i]) return i;

    return -1;
}

static int find_samplerate_index(long freq)
{
    static long mpeg1[3] = {44100, 48000, 32000};
    int i;

    for(i=0;i<3;i++)
        if(freq==mpeg1[i]) return i;

    return -1;
}


int  num_file;
char filename[12][80];
char mp3_name[80];

void read_wav_files(char *dirname)
{
    DIR *dir = rb->opendir(dirname);

    if(!dir)
        return;

    while(true)
    {
        struct dirent *entry;

        entry = rb->readdir(dir);
        if(!entry)
            break;

        if( !(entry->attribute & ATTR_DIRECTORY) )
        {
            int slen = rb->strlen(entry->d_name);
            
            /* add all wav audio files */
            if(!rb->strcasecmp(entry->d_name + slen - 4, ".wav"))
            {
                if(num_file >= 12)
                    break;

                rb->strncpy(filename[num_file], dirname, 79);
                slen = rb->strlen(filename[num_file]);
                rb->strncpy(filename[num_file++] + slen, entry->d_name, 79);
            }
        }
    }
    rb->closedir(dir);
}

char *get_mp3_filename(char *wav_name)
{
    int slen = rb->strlen(wav_name);
    rb->strncpy(mp3_name, wav_name, 79);
    rb->strncpy(mp3_name + slen - 4, ".mp3", 5);

    return mp3_name;
}

#if CONFIG_KEYPAD == IRIVER_H100_PAD || CONFIG_KEYPAD == IRIVER_H300_PAD
#define MP3ENC_PREV BUTTON_UP
#define MP3ENC_NEXT BUTTON_DOWN
#define MP3ENC_DONE BUTTON_OFF
#define MP3ENC_SELECT BUTTON_SELECT
#elif CONFIG_KEYPAD == IPOD_4G_PAD
#define MP3ENC_PREV BUTTON_SCROLL_BACK
#define MP3ENC_NEXT BUTTON_SCROLL_FWD
#define MP3ENC_DONE BUTTON_MENU
#define MP3ENC_SELECT BUTTON_SELECT
#endif

enum plugin_status plugin_start(struct plugin_api* api, void* parameter)
{
    int   fil, sfil, nfil; /* for file selection */
    int   rat, srat, nrat; /* for rate selection */
    int   i, cont, butt;
    long  tim = 0;
    char  stg[40];
    char  *bitratename[] = { "64","80","96","112","128","160","192","224","256","320" };
    int   brate[]        = { 64,80,96,112,128,160,192,224,256,320 };

    (void)parameter;
    rb = api;

    rb->lcd_setfont(FONT_SYSFIXED);

#ifdef HAVE_ADJUSTABLE_CPU_FREQ
    rb->cpu_boost(true);
#endif
    rb->button_clear_queue();

    read_wav_files("/");
    read_wav_files(REC_BASE_DIR"/");

    nfil = num_file - 1;
    sfil = 0; /* set first file as default */
    cont = 1;

    while(cont && (butt = rb->button_get_w_tmo(HZ/10)) != MP3ENC_SELECT)
    {
        switch(butt)
        {
            case MP3ENC_DONE:   cont = 0;               break;
            case MP3ENC_PREV:   if(sfil >  0  ) sfil--; break;
            case MP3ENC_NEXT:   if(sfil < nfil) sfil++; break;
        }

        rb->lcd_clear_display();
        rb->lcd_putsxy(2, 2, "-- Select WAV-File --");

        for(fil=0; fil<=nfil; fil++)
            rb->lcd_putsxy(2, 12 + fil*8, filename[fil]);
        rb->lcd_set_drawmode(DRMODE_COMPLEMENT);
        rb->lcd_fillrect(0, 12 + sfil*8, 127, 8);
        rb->lcd_set_drawmode(DRMODE_SOLID);
        rb->lcd_update();
    }

    nrat = 9;
    srat = 4; /* set 128kBit as default */

    while(cont && (butt = rb->button_get_w_tmo(HZ/10)) != MP3ENC_SELECT)
    {
        switch(butt)
        {
            case MP3ENC_DONE:   cont = 0;               break;
            case MP3ENC_PREV:   if(srat >  0  ) srat--; break;
            case MP3ENC_NEXT:   if(srat < nrat) srat++; break;
        }

        rb->lcd_clear_display();
        rb->lcd_putsxy(2, 2, "-- Select Bitrate --");

        for(rat=0; rat<=nrat; rat++)
            rb->lcd_putsxy(2, 12 + rat*8, bitratename[rat]);
        rb->lcd_set_drawmode(DRMODE_COMPLEMENT);
        rb->lcd_fillrect(0, 12 + srat*8, 127, 8);
        rb->lcd_set_drawmode(DRMODE_SOLID);
        rb->lcd_update();
    }

    config.infile             = filename[sfil];
    config.outfile            = get_mp3_filename(filename[sfil]);
#ifdef ROCKBOX_LITTLE_ENDIAN
    config.byte_order         = order_littleEndian;
#else
    config.byte_order         = order_bigEndian;
#endif
    config.mpeg.type          = 1;
    config.mpeg.layr          = 2;
    config.mpeg.mode          = 2;
    config.mpeg.bitr          = brate[srat];
    config.mpeg.emph          = 0; 
    config.mpeg.crc           = 0;
    config.mpeg.ext           = 0;
    config.mpeg.mode_ext      = 0;
    config.mpeg.copyright     = 0;
    config.mpeg.original      = 1;
    config.mpeg.bitrate_index = find_bitrate_index(config.mpeg.bitr);

    if(cont)
    {
        if((i=wave_open()) == 0)
        {
            config.mpeg.samplerate_index = find_samplerate_index(config.wave.samplerate);

            tim = *rb->current_tick;
            compress();
            tim = *rb->current_tick - tim;

    	      wave_close();
            rb->close(*mp3file);
        }
        else
        {
            rb->snprintf(stg, 20, "WaveOpen failed: %d", i);
            rb->lcd_putsxy(0, 20, stg);
            rb->lcd_update();
            rb->sleep(2*HZ);
        }

        rb->lcd_clear_display();
        rb->snprintf(stg, 30, "    Conversion: %d.%02ds     ", tim/100, tim%100);
        rb->lcd_putsxy(0, 30, stg);
        tim = frames_processed * samp_per_frame * 100 / 44100; /* unit=.01s */
        rb->snprintf(stg, 30, "    WAV-Length: %d.%02ds     ", tim/100, tim%100);
        rb->lcd_putsxy(0, 20, stg);
        rb->lcd_update();
        rb->sleep(5*HZ);
    }

    rb->lcd_setfont(FONT_UI);
#ifdef HAVE_ADJUSTABLE_CPU_FREQ
    rb->cpu_boost(false);
#endif
    return PLUGIN_OK;
}
